---
description: CLI 및 웹 인터페이스 개발을 위한 사용자 경험 최적화 규칙
globs: "frontend/**/*.py"
alwaysApply: false
---

<rule>
<meta>
<title>CLI and Web Interface Development Standards</title>
<description>사용자 친화적인 CLI와 Streamlit 웹 인터페이스 개발을 위한 UX/UI 가이드라인</description>
<created-at utc-timestamp="1720684800">2025-07-08, 11:40 AM KST</created-at>
<last-updated-at utc-timestamp="1720684800">2025-07-08, 11:40 AM KST</last-updated-at>
<applies-to>
<file-matcher glob="frontend/**/*.py">프론트엔드 관련 파일</file-matcher>
<file-matcher glob="cli.py">CLI 메인 파일</file-matcher>
<file-matcher glob="app.py">웹 앱 메인 파일</file-matcher>
</applies-to>
</meta>

<requirements>
<requirement priority="critical">
<description>Rich Console을 사용하여 CLI에서 아름답고 정보가 풍부한 출력을 제공한다.</description>
<examples>
<example title="Rich Console 활용">
<correct-example title="풍부한 CLI 출력" conditions="CLI 메시지 표시" expected-result="시각적으로 매력적인 출력" correctness-criteria="Rich 컴포넌트 활용"><![CDATA[
from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn, TaskProgressColumn
from rich.table import Table
from rich.syntax import Syntax
from rich.markdown import Markdown
from rich import box
from rich.layout import Layout
from rich.live import Live
import asyncio

class DecepticonCLI:
    """Decepticon CLI 인터페이스"""
    
    def __init__(self):
        self.console = Console()
        self.theme = {
            "primary": "cyan",
            "secondary": "blue", 
            "success": "green",
            "warning": "yellow",
            "error": "red",
            "info": "white"
        }
    
    def display_banner(self):
        """Decepticon 시작 배너 표시"""
        banner_text = """
# 🤖 DECEPTICON
## Vibe Hacking Agent

*AI-Powered Red Team Testing Framework*
        """
        
        banner_panel = Panel(
            Markdown(banner_text),
            box=box.DOUBLE,
            border_style=self.theme["primary"],
            title="[bold cyan]Welcome to Decepticon[/bold cyan]",
            title_align="center"
        )
        
        self.console.print(banner_panel)
        self.console.print()
    
    def display_agent_status(self, agents_info: Dict[str, Any]):
        """에이전트 상태 테이블 표시"""
        table = Table(
            title="🔍 Agent Status",
            box=box.ROUNDED,
            header_style="bold cyan"
        )
        
        table.add_column("Agent", style="bold white", width=20)
        table.add_column("Status", justify="center", width=12)
        table.add_column("Tools", justify="center", width=8) 
        table.add_column("Last Activity", style="dim", width=20)
        
        for agent_name, info in agents_info.items():
            status_style = self._get_status_style(info.get("status", "unknown"))
            status_icon = self._get_status_icon(info.get("status", "unknown"))
            
            table.add_row(
                f"[{self.theme['primary']}]{agent_name}[/{self.theme['primary']}]",
                f"[{status_style}]{status_icon} {info.get('status', 'Unknown')}[/{status_style}]",
                str(info.get("tool_count", 0)),
                info.get("last_activity", "Never")
            )
        
        self.console.print(table)
        self.console.print()
    
    async def display_operation_progress(self, operation_name: str, tasks: List[str]):
        """실시간 작업 진행상황 표시"""
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            TaskProgressColumn(),
            console=self.console
        ) as progress:
            
            main_task = progress.add_task(
                f"[{self.theme['primary']}]{operation_name}[/{self.theme['primary']}]", 
                total=len(tasks)
            )
            
            for i, task_name in enumerate(tasks):
                sub_task = progress.add_task(f"  └─ {task_name}", total=100)
                
                # 작업 시뮬레이션
                for step in range(100):
                    await asyncio.sleep(0.02)  # 실제 작업으로 대체
                    progress.update(sub_task, advance=1)
                
                progress.update(main_task, advance=1)
                progress.remove_task(sub_task)
    
    def display_scan_results(self, scan_results: Dict[str, Any]):
        """스캔 결과 표시"""
        target = scan_results.get("target", "Unknown")
        
        # 결과 헤더
        header_panel = Panel(
            f"[bold {self.theme['primary']}]Scan Results for {target}[/bold {self.theme['primary']}]",
            box=box.ROUNDED,
            border_style=self.theme["primary"]
        )
        self.console.print(header_panel)
        
        # 포트 스캔 결과 테이블
        if "ports" in scan_results:
            ports_table = Table(
                title="Open Ports",
                box=box.SIMPLE,
                header_style="bold green"
            )
            ports_table.add_column("Port", justify="center")
            ports_table.add_column("Protocol", justify="center")
            ports_table.add_column("Service", style="cyan")
            ports_table.add_column("Version", style="dim")
            
            for port_info in scan_results["ports"]:
                ports_table.add_row(
                    str(port_info.get("port", "")),
                    port_info.get("protocol", "TCP").upper(),
                    port_info.get("service", "Unknown"),
                    port_info.get("version", "N/A")
                )
            
            self.console.print(ports_table)
        
        # 취약점 요약
        if "vulnerabilities" in scan_results:
            vulns = scan_results["vulnerabilities"]
            
            vuln_summary = Panel(
                f"[red]Critical: {vulns.get('critical', 0)}[/red] | "
                f"[yellow]High: {vulns.get('high', 0)}[/yellow] | "
                f"[blue]Medium: {vulns.get('medium', 0)}[/blue] | "
                f"[dim]Low: {vulns.get('low', 0)}[/dim]",
                title="[bold red]Vulnerability Summary[/bold red]",
                box=box.SIMPLE
            )
            self.console.print(vuln_summary)
        
        self.console.print()
    
    def display_code_snippet(self, code: str, language: str = "python"):
        """코드 스니펫 하이라이팅"""
        syntax = Syntax(
            code, 
            language, 
            theme="monokai",
            line_numbers=True,
            word_wrap=True
        )
        
        code_panel = Panel(
            syntax,
            title=f"[bold {self.theme['secondary']}]{language.upper()} Code[/bold {self.theme['secondary']}]",
            border_style=self.theme["secondary"]
        )
        
        self.console.print(code_panel)
    
    def display_error_message(self, error_message: str, suggestions: List[str] = None):
        """에러 메시지 표시"""
        error_content = f"[bold red]❌ Error:[/bold red] {error_message}"
        
        if suggestions:
            error_content += "\n\n[bold yellow]💡 Suggestions:[/bold yellow]"
            for i, suggestion in enumerate(suggestions, 1):
                error_content += f"\n  {i}. {suggestion}"
        
        error_panel = Panel(
            error_content,
            box=box.HEAVY,
            border_style="red",
            title="[bold red]Error[/bold red]"
        )
        
        self.console.print(error_panel)
    
    def display_success_message(self, message: str, details: str = None):
        """성공 메시지 표시"""
        success_content = f"[bold green]✅ {message}[/bold green]"
        
        if details:
            success_content += f"\n\n[dim]{details}[/dim]"
        
        success_panel = Panel(
            success_content,
            box=box.ROUNDED,
            border_style="green",
            title="[bold green]Success[/bold green]"
        )
        
        self.console.print(success_panel)
    
    def _get_status_style(self, status: str) -> str:
        """상태에 따른 스타일 반환"""
        status_styles = {
            "active": "green",
            "ready": "cyan", 
            "busy": "yellow",
            "error": "red",
            "inactive": "dim"
        }
        return status_styles.get(status.lower(), "white")
    
    def _get_status_icon(self, status: str) -> str:
        """상태에 따른 아이콘 반환"""
        status_icons = {
            "active": "🟢",
            "ready": "🔵",
            "busy": "🟡", 
            "error": "🔴",
            "inactive": "⚫"
        }
        return status_icons.get(status.lower(), "❓")

# CLI 사용 예시
async def main_cli_interface():
    """메인 CLI 인터페이스"""
    cli = DecepticonCLI()
    
    # 배너 표시
    cli.display_banner()
    
    # 에이전트 상태 표시
    agents_info = {
        "Planner": {"status": "ready", "tool_count": 3, "last_activity": "2025-07-08 11:30"},
        "Reconnaissance": {"status": "active", "tool_count": 8, "last_activity": "2025-07-08 11:35"},
        "Initial Access": {"status": "ready", "tool_count": 5, "last_activity": "2025-07-08 10:45"},
        "Summary": {"status": "inactive", "tool_count": 2, "last_activity": "Never"}
    }
    
    cli.display_agent_status(agents_info)
    
    # 작업 진행상황 표시 예시
    await cli.display_operation_progress(
        "Network Reconnaissance",
        ["Port Scanning", "Service Detection", "Vulnerability Assessment", "Report Generation"]
    )
]]></correct-example>
<incorrect-example title="기본 print 사용" conditions="CLI 메시지 표시" expected-result="시각적으로 매력적인 출력" incorrectness-criteria="Rich 컴포넌트 미사용"><![CDATA[
def basic_cli_output():
    """기본적인 CLI 출력 (개선 필요)"""
    print("Decepticon - AI Red Team Testing")
    print("================================")
    print("Agent Status:")
    print("- Planner: Ready")
    print("- Reconnaissance: Active") 
    print("- Initial Access: Ready")
    print("")
    print("Starting operation...")
]]></incorrect-example>
</example>
</examples>
</requirement>

<requirement priority="high">
<description>Streamlit 웹 인터페이스는 반응형이고 직관적인 사용자 경험을 제공한다.</description>
<examples>
<example title="Streamlit UI 컴포넌트">
<correct-example title="반응형 웹 인터페이스" conditions="웹 UI 구성요소 개발" expected-result="사용자 친화적 인터페이스" correctness-criteria="Streamlit 컴포넌트 활용"><![CDATA[
import streamlit as st
from typing import Dict, Any, List, Optional
import plotly.graph_objects as go
import plotly.express as px
import pandas as pd
from datetime import datetime, timedelta

class DecepticonWebUI:
    """Decepticon 웹 인터페이스"""
    
    def __init__(self):
        self.setup_page_config()
        self.init_session_state()
    
    def setup_page_config(self):
        """페이지 설정"""
        st.set_page_config(
            page_title="Decepticon",
            page_icon="🤖",
            layout="wide",
            initial_sidebar_state="expanded"
        )
    
    def init_session_state(self):
        """세션 상태 초기화"""
        if "messages" not in st.session_state:
            st.session_state.messages = []
        if "current_operation" not in st.session_state:
            st.session_state.current_operation = None
        if "scan_results" not in st.session_state:
            st.session_state.scan_results = {}
    
    def render_header(self):
        """헤더 렌더링"""
        col1, col2, col3 = st.columns([2, 6, 2])
        
        with col1:
            st.image("assets/logo.png", width=80)
        
        with col2:
            st.title("🤖 Decepticon")
            st.caption("AI-Powered Red Team Testing Framework")
        
        with col3:
            # 상태 표시기
            if st.session_state.current_operation:
                st.success("🟢 Active")
            else:
                st.info("🔵 Ready")
    
    def render_sidebar(self):
        """사이드바 렌더링"""
        with st.sidebar:
            st.header("🎯 Mission Control")
            
            # 에이전트 선택
            selected_agent = st.selectbox(
                "Select Agent",
                ["Planner", "Reconnaissance", "Initial Access", "Summary"],
                help="Choose which agent to interact with"
            )
            
            # 타겟 설정
            target_input = st.text_input(
                "Target",
                placeholder="192.168.1.1 or example.com",
                help="Enter IP address or domain name"
            )
            
            # 스캔 옵션
            st.subheader("🔧 Scan Options")
            
            scan_type = st.radio(
                "Scan Type",
                ["Quick Scan", "Full Scan", "Stealth Scan"],
                help="Select scanning intensity"
            )
            
            port_range = st.text_input(
                "Port Range",
                value="1-1000",
                help="e.g., 1-1000, 80,443,8080"
            )
            
            # 고급 옵션
            with st.expander("🔧 Advanced Options"):
                timeout = st.slider("Timeout (seconds)", 1, 60, 30)
                threads = st.slider("Concurrent Threads", 1, 20, 5)
                stealth_mode = st.checkbox("Stealth Mode")
            
            # 실행 버튼
            if st.button("🚀 Start Operation", type="primary", use_container_width=True):
                if target_input:
                    self.start_operation(selected_agent, target_input, {
                        "scan_type": scan_type,
                        "port_range": port_range,
                        "timeout": timeout,
                        "threads": threads,
                        "stealth_mode": stealth_mode
                    })
                else:
                    st.error("Please enter a target")
            
            # 중지 버튼
            if st.session_state.current_operation:
                if st.button("⏹️ Stop Operation", type="secondary", use_container_width=True):
                    self.stop_operation()
    
    def render_main_content(self):
        """메인 콘텐츠 렌더링"""
        # 탭 구성
        tab1, tab2, tab3, tab4 = st.tabs(["💬 Chat", "📊 Results", "📈 Analytics", "⚙️ Settings"])
        
        with tab1:
            self.render_chat_interface()
        
        with tab2:
            self.render_results_dashboard()
        
        with tab3:
            self.render_analytics_dashboard()
        
        with tab4:
            self.render_settings_panel()
    
    def render_chat_interface(self):
        """채팅 인터페이스 렌더링"""
        # 메시지 표시 영역
        chat_container = st.container()
        with chat_container:
            for message in st.session_state.messages:
                with st.chat_message(message["role"]):
                    if message["role"] == "assistant":
                        # 에이전트 응답에 메타데이터 표시
                        col1, col2 = st.columns([3, 1])
                        with col1:
                            st.markdown(message["content"])
                        with col2:
                            if "agent" in message:
                                st.caption(f"🤖 {message['agent']}")
                            if "timestamp" in message:
                                st.caption(f"⏰ {message['timestamp']}")
                    else:
                        st.markdown(message["content"])
        
        # 메시지 입력
        if prompt := st.chat_input("Enter your command or question..."):
            self.handle_user_input(prompt)
    
    def render_results_dashboard(self):
        """결과 대시보드 렌더링"""
        if not st.session_state.scan_results:
            st.info("📝 No scan results yet. Start an operation to see results here.")
            return
        
        results = st.session_state.scan_results
        
        # 결과 요약 카드
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric(
                "Targets Scanned",
                value=results.get("targets_count", 0),
                delta=f"+{results.get('new_targets', 0)}"
            )
        
        with col2:
            st.metric(
                "Open Ports",
                value=results.get("open_ports", 0),
                delta=f"+{results.get('new_ports', 0)}"
            )
        
        with col3:
            st.metric(
                "Vulnerabilities",
                value=results.get("vulnerabilities", 0),
                delta=f"+{results.get('new_vulns', 0)}"
            )
        
        with col4:
            st.metric(
                "Risk Score",
                value=f"{results.get('risk_score', 0):.1f}",
                delta=f"{results.get('risk_change', 0):+.1f}"
            )
        
        # 상세 결과 테이블
        if "detailed_results" in results:
            st.subheader("📋 Detailed Results")
            
            df = pd.DataFrame(results["detailed_results"])
            
            # 필터링 옵션
            col1, col2 = st.columns(2)
            with col1:
                severity_filter = st.multiselect(
                    "Filter by Severity",
                    options=["Critical", "High", "Medium", "Low"],
                    default=["Critical", "High"]
                )
            
            with col2:
                service_filter = st.multiselect(
                    "Filter by Service",
                    options=df["service"].unique() if "service" in df.columns else []
                )
            
            # 필터링된 데이터 표시
            filtered_df = df
            if severity_filter and "severity" in df.columns:
                filtered_df = filtered_df[filtered_df["severity"].isin(severity_filter)]
            if service_filter and "service" in df.columns:
                filtered_df = filtered_df[filtered_df["service"].isin(service_filter)]
            
            st.dataframe(
                filtered_df,
                use_container_width=True,
                hide_index=True
            )
    
    def render_analytics_dashboard(self):
        """분석 대시보드 렌더링"""
        st.subheader("📈 Security Analytics")
        
        # 가상의 분석 데이터 생성 (실제로는 실제 데이터 사용)
        dates = pd.date_range(start=datetime.now()-timedelta(days=30), end=datetime.now(), freq='D')
        vulnerability_data = {
            'Date': dates,
            'Critical': np.random.randint(0, 5, len(dates)),
            'High': np.random.randint(5, 15, len(dates)),
            'Medium': np.random.randint(10, 25, len(dates)),
            'Low': np.random.randint(15, 35, len(dates))
        }
        
        df = pd.DataFrame(vulnerability_data)
        
        # 취약점 트렌드 차트
        fig = go.Figure()
        
        for severity in ['Critical', 'High', 'Medium', 'Low']:
            fig.add_trace(go.Scatter(
                x=df['Date'],
                y=df[severity],
                mode='lines+markers',
                name=severity,
                line=dict(width=2)
            ))
        
        fig.update_layout(
            title="Vulnerability Trends (Last 30 Days)",
            xaxis_title="Date",
            yaxis_title="Count",
            hovermode='x unified'
        )
        
        st.plotly_chart(fig, use_container_width=True)
        
        # 포트 분포 차트
        col1, col2 = st.columns(2)
        
        with col1:
            # 포트 분포 파이 차트
            port_data = {'SSH': 15, 'HTTP': 25, 'HTTPS': 20, 'FTP': 8, 'Others': 32}
            
            fig_pie = px.pie(
                values=list(port_data.values()),
                names=list(port_data.keys()),
                title="Service Distribution"
            )
            
            st.plotly_chart(fig_pie, use_container_width=True)
        
        with col2:
            # 위험도 분포 바 차트
            risk_data = {'Low': 45, 'Medium': 30, 'High': 20, 'Critical': 5}
            
            fig_bar = px.bar(
                x=list(risk_data.keys()),
                y=list(risk_data.values()),
                title="Risk Level Distribution",
                color=list(risk_data.keys()),
                color_discrete_map={
                    'Low': 'green',
                    'Medium': 'yellow', 
                    'High': 'orange',
                    'Critical': 'red'
                }
            )
            
            st.plotly_chart(fig_bar, use_container_width=True)
    
    def render_settings_panel(self):
        """설정 패널 렌더링"""
        st.subheader("⚙️ Configuration")
        
        # LLM 설정
        with st.expander("🧠 AI Model Settings", expanded=True):
            llm_provider = st.selectbox(
                "LLM Provider",
                ["OpenAI", "Anthropic", "Groq", "Local (Ollama)"]
            )
            
            model_map = {
                "OpenAI": ["gpt-4o", "gpt-4", "gpt-3.5-turbo"],
                "Anthropic": ["claude-3-5-sonnet", "claude-3-opus", "claude-3-haiku"],
                "Groq": ["llama3-70b", "mixtral-8x7b"],
                "Local (Ollama)": ["llama3", "codellama", "mistral"]
            }
            
            selected_model = st.selectbox(
                "Model",
                model_map.get(llm_provider, [])
            )
            
            temperature = st.slider("Temperature", 0.0, 1.0, 0.0, 0.1)
        
        # 보안 설정
        with st.expander("🔒 Security Settings"):
            auto_approve = st.checkbox("Auto-approve low-risk operations")
            
            allowed_networks = st.text_area(
                "Allowed Networks",
                value="192.168.0.0/16\n10.0.0.0/8\n172.16.0.0/12",
                help="One network per line"
            )
            
            max_concurrent = st.number_input("Max Concurrent Operations", 1, 10, 3)
        
        # 로깅 설정
        with st.expander("📝 Logging Settings"):
            log_level = st.selectbox(
                "Log Level",
                ["DEBUG", "INFO", "WARNING", "ERROR"]
            )
            
            save_conversations = st.checkbox("Save Conversation History", value=True)
            
            export_format = st.selectbox(
                "Export Format",
                ["JSON", "CSV", "PDF"]
            )
        
        # 설정 저장 버튼
        if st.button("💾 Save Settings", type="primary"):
            self.save_settings({
                "llm_provider": llm_provider,
                "model": selected_model,
                "temperature": temperature,
                "auto_approve": auto_approve,
                "allowed_networks": allowed_networks,
                "max_concurrent": max_concurrent,
                "log_level": log_level,
                "save_conversations": save_conversations,
                "export_format": export_format
            })
    
    def start_operation(self, agent: str, target: str, options: Dict[str, Any]):
        """작업 시작"""
        st.session_state.current_operation = {
            "agent": agent,
            "target": target,
            "options": options,
            "start_time": datetime.now()
        }
        
        st.success(f"Started {agent} operation on {target}")
        st.rerun()
    
    def stop_operation(self):
        """작업 중지"""
        st.session_state.current_operation = None
        st.info("Operation stopped")
        st.rerun()
    
    def handle_user_input(self, prompt: str):
        """사용자 입력 처리"""
        # 사용자 메시지 추가
        st.session_state.messages.append({
            "role": "user",
            "content": prompt,
            "timestamp": datetime.now().strftime("%H:%M:%S")
        })
        
        # 에이전트 응답 시뮬레이션 (실제로는 에이전트 호출)
        response = f"Processing your request: {prompt}"
        
        st.session_state.messages.append({
            "role": "assistant",
            "content": response,
            "agent": "Planner",
            "timestamp": datetime.now().strftime("%H:%M:%S")
        })
        
        st.rerun()

# 메인 웹 앱 실행
def main_web_app():
    """메인 웹 애플리케이션"""
    ui = DecepticonWebUI()
    
    ui.render_header()
    ui.render_sidebar()
    ui.render_main_content()

if __name__ == "__main__":
    main_web_app()
]]></correct-example>
<incorrect-example title="기본 Streamlit 사용" conditions="웹 UI 구성요소 개발" expected-result="사용자 친화적 인터페이스" incorrectness-criteria="기본적인 컴포넌트만 사용"><![CDATA[
import streamlit as st

def basic_web_app():
    """기본적인 웹 앱 (개선 필요)"""
    st.title("Decepticon")
    
    target = st.text_input("Target")
    if st.button("Scan"):
        st.write(f"Scanning {target}...")
    
    st.write("Results will appear here")
]]></incorrect-example>
</example>
</examples>
</requirement>

<requirement priority="high">
<description>실시간 피드백과 진행상황 표시를 통해 사용자 경험을 향상시킨다.</description>
<examples>
<example title="실시간 UI 업데이트">
<correct-example title="동적 진행상황 표시" conditions="장시간 작업 진행" expected-result="실시간 피드백" correctness-criteria="진행률과 상태 업데이트"><![CDATA[
import streamlit as st
import asyncio
import time
from typing import AsyncGenerator, Dict, Any

class RealTimeUI:
    """실시간 UI 업데이트 관리자"""
    
    def __init__(self):
        self.progress_placeholder = None
        self.status_placeholder = None
        self.results_placeholder = None
    
    def setup_progress_display(self):
        """진행상황 표시 영역 설정"""
        self.progress_placeholder = st.empty()
        self.status_placeholder = st.empty()
        self.results_placeholder = st.empty()
    
    async def run_operation_with_progress(
        self, 
        operation_func: callable, 
        operation_name: str,
        **kwargs
    ) -> Dict[str, Any]:
        """진행상황과 함께 작업 실행"""
        
        # 진행상황 표시 설정
        self.setup_progress_display()
        
        # 전체 진행률 바
        progress_bar = self.progress_placeholder.progress(0)
        status_text = self.status_placeholder.empty()
        
        try:
            # 작업 실행 및 진행상황 업데이트
            async for progress_data in operation_func(**kwargs):
                # 진행률 업데이트
                if "progress" in progress_data:
                    progress_bar.progress(progress_data["progress"] / 100)
                
                # 상태 메시지 업데이트
                if "status" in progress_data:
                    status_text.info(f"🔄 {progress_data['status']}")
                
                # 중간 결과 표시
                if "partial_result" in progress_data:
                    self.display_partial_result(progress_data["partial_result"])
                
                # UI 업데이트를 위한 짧은 대기
                await asyncio.sleep(0.1)
            
            # 완료 표시
            progress_bar.progress(100)
            status_text.success("✅ Operation completed successfully!")
            
            return {"status": "completed", "message": "Operation finished"}
        
        except Exception as e:
            status_text.error(f"❌ Operation failed: {str(e)}")
            return {"status": "failed", "error": str(e)}
    
    def display_partial_result(self, result: Dict[str, Any]):
        """부분 결과 표시"""
        with self.results_placeholder.container():
            if "new_port" in result:
                st.success(f"🔍 Found open port: {result['new_port']}")
            
            if "vulnerability" in result:
                vuln = result["vulnerability"]
                severity_colors = {
                    "critical": "🔴",
                    "high": "🟠", 
                    "medium": "🟡",
                    "low": "🟢"
                }
                
                severity = vuln.get("severity", "unknown").lower()
                icon = severity_colors.get(severity, "🔵")
                
                st.warning(f"{icon} Vulnerability found: {vuln.get('name', 'Unknown')}")
            
            if "service" in result:
                st.info(f"🔧 Service detected: {result['service']}")

class StreamingChat:
    """스트리밍 채팅 인터페이스"""
    
    def __init__(self):
        self.message_placeholder = None
    
    async def stream_agent_response(self, agent_func: callable, user_message: str):
        """에이전트 응답 스트리밍"""
        
        # 메시지 플레이스홀더 생성
        self.message_placeholder = st.empty()
        
        # 타이핑 인디케이터 표시
        with self.message_placeholder.container():
            with st.chat_message("assistant"):
                typing_placeholder = st.empty()
                
                # 타이핑 애니메이션
                for i in range(3):
                    typing_placeholder.markdown("🤖 Thinking" + "." * (i + 1))
                    await asyncio.sleep(0.5)
        
        # 실제 응답 스트리밍
        response_text = ""
        
        async for chunk in agent_func(user_message):
            response_text += chunk.get("text", "")
            
            # 실시간으로 응답 업데이트
            with self.message_placeholder.container():
                with st.chat_message("assistant"):
                    st.markdown(response_text + "▌")  # 커서 표시
            
            await asyncio.sleep(0.05)  # 타이핑 효과
        
        # 최종 응답 표시 (커서 제거)
        with self.message_placeholder.container():
            with st.chat_message("assistant"):
                st.markdown(response_text)
                
                # 메타데이터 표시
                col1, col2 = st.columns([3, 1])
                with col2:
                    st.caption(f"🤖 {chunk.get('agent', 'Unknown')}")
                    st.caption(f"⏰ {datetime.now().strftime('%H:%M:%S')}")

# 실시간 스캔 시뮬레이션
async def simulate_network_scan(target: str) -> AsyncGenerator[Dict[str, Any], None]:
    """네트워크 스캔 시뮬레이션"""
    
    ports_to_scan = [22, 23, 25, 53, 80, 110, 143, 443, 993, 995]
    total_ports = len(ports_to_scan)
    
    yield {"status": f"Starting scan on {target}", "progress": 0}
    await asyncio.sleep(1)
    
    for i, port in enumerate(ports_to_scan):
        # 포트 스캔 시뮬레이션
        yield {"status": f"Scanning port {port}", "progress": (i * 100) // total_ports}
        await asyncio.sleep(0.5)
        
        # 랜덤하게 열린 포트 발견
        if port in [22, 80, 443]:
            yield {
                "partial_result": {"new_port": port},
                "progress": (i * 100) // total_ports
            }
            
            # 서비스 감지
            services = {22: "SSH", 80: "HTTP", 443: "HTTPS"}
            yield {
                "partial_result": {"service": services[port]},
                "progress": (i * 100) // total_ports
            }
        
        # 취약점 발견 시뮬레이션
        if port == 22:
            yield {
                "partial_result": {
                    "vulnerability": {
                        "name": "Weak SSH Configuration",
                        "severity": "medium"
                    }
                },
                "progress": (i * 100) // total_ports
            }
    
    yield {"status": "Scan completed", "progress": 100}

# 실시간 에이전트 응답 시뮬레이션
async def simulate_agent_response(user_message: str) -> AsyncGenerator[Dict[str, Any], None]:
    """에이전트 응답 시뮬레이션"""
    
    response_parts = [
        "I understand you want to ",
        f"perform '{user_message}'. ",
        "Let me analyze the request and ",
        "provide you with the best approach. ",
        "\n\nBased on my analysis, ",
        "I recommend starting with ",
        "reconnaissance to gather ",
        "information about the target. ",
        "\n\nWould you like me to ",
        "proceed with this plan?"
    ]
    
    for part in response_parts:
        yield {"text": part, "agent": "Planner"}
        await asyncio.sleep(0.1)

# 사용 예시
async def demo_real_time_interface():
    """실시간 인터페이스 데모"""
    st.header("🔄 Real-Time Operations")
    
    # 실시간 스캔 데모
    if st.button("Start Network Scan"):
        ui = RealTimeUI()
        await ui.run_operation_with_progress(
            simulate_network_scan,
            "Network Scan",
            target="192.168.1.1"
        )
    
    # 스트리밍 채팅 데모
    if prompt := st.chat_input("Ask the AI agent..."):
        chat = StreamingChat()
        await chat.stream_agent_response(simulate_agent_response, prompt)
]]></correct-example>
<incorrect-example title="정적 업데이트" conditions="장시간 작업 진행" expected-result="실시간 피드백" incorrectness-criteria="진행상황 표시 없음"><![CDATA[
def static_operation():
    """정적 작업 실행 (개선 필요)"""
    if st.button("Start Scan"):
        st.write("Scanning...")
        # 장시간 작업 수행 (진행상황 표시 없음)
        time.sleep(10)
        st.write("Scan completed")
]]></incorrect-example>
</example>
</examples>
</requirement>

<non-negotiable priority="critical">
<description>보안 관련 작업은 사용자 확인 없이 자동 실행되지 않도록 보호한다.</description>
<examples>
<example title="보안 작업 승인 UI">
<correct-example title="사용자 승인 인터페이스" conditions="위험한 보안 작업 실행" expected-result="명시적 사용자 승인" correctness-criteria="승인 다이얼로그와 경고 메시지"><![CDATA[
import streamlit as st
from typing import Dict, Any, Optional
from enum import Enum

class RiskLevel(Enum):
    LOW = "low"
    MEDIUM = "medium" 
    HIGH = "high"
    CRITICAL = "critical"

class SecurityApprovalUI:
    """보안 작업 승인 UI"""
    
    def __init__(self):
        self.risk_colors = {
            RiskLevel.LOW: "green",
            RiskLevel.MEDIUM: "blue", 
            RiskLevel.HIGH: "orange",
            RiskLevel.CRITICAL: "red"
        }
        
        self.risk_icons = {
            RiskLevel.LOW: "🟢",
            RiskLevel.MEDIUM: "🔵",
            RiskLevel.HIGH: "🟠", 
            RiskLevel.CRITICAL: "🔴"
        }
    
    def show_approval_dialog(
        self,
        operation: str,
        target: str,
        risk_level: RiskLevel,
        details: Dict[str, Any],
        warnings: Optional[List[str]] = None
    ) -> bool:
        """보안 작업 승인 다이얼로그 표시"""
        
        # 위험도에 따른 스타일링
        color = self.risk_colors[risk_level]
        icon = self.risk_icons[risk_level]
        
        # 승인 다이얼로그
        with st.container():
            # 경고 헤더
            st.markdown(f"""
            <div style="
                border: 3px solid {color}; 
                border-radius: 10px; 
                padding: 20px; 
                background-color: rgba(255,255,255,0.05);
                margin: 20px 0;
            ">
            """, unsafe_allow_html=True)
            
            # 위험도 표시
            st.markdown(f"### {icon} Security Operation Approval Required")
            st.markdown(f"**Risk Level: {risk_level.value.upper()}**")
            
            # 작업 정보
            col1, col2 = st.columns(2)
            with col1:
                st.markdown(f"**Operation:** {operation}")
                st.markdown(f"**Target:** {target}")
            
            with col2:
                st.markdown(f"**Date:** {datetime.now().strftime('%Y-%m-%d %H:%M')}")
                st.markdown(f"**User:** {st.session_state.get('user_id', 'Unknown')}")
            
            # 작업 세부사항
            if details:
                st.markdown("**Operation Details:**")
                for key, value in details.items():
                    st.markdown(f"- **{key}:** {value}")
            
            # 경고 메시지
            if warnings:
                st.markdown("**⚠️ Warnings:**")
                for warning in warnings:
                    st.warning(warning)
            
            # 위험도별 추가 경고
            if risk_level == RiskLevel.CRITICAL:
                st.error("""
                🚨 **CRITICAL RISK OPERATION** 🚨
                
                This operation may cause:
                - System damage or data loss
                - Service disruption
                - Security policy violations
                
                Ensure you have proper authorization and backups.
                """)
            
            elif risk_level == RiskLevel.HIGH:
                st.warning("""
                ⚠️ **HIGH RISK OPERATION**
                
                This operation may:
                - Modify system configurations
                - Access sensitive data
                - Trigger security alerts
                
                Verify target authorization before proceeding.
                """)
            
            # 승인 체크박스
            st.markdown("---")
            
            # 필수 확인 사항
            confirmations = []
            
            confirmations.append(st.checkbox(
                "✅ I confirm that I have authorization to perform this operation on the specified target",
                key=f"auth_confirm_{operation}"
            ))
            
            confirmations.append(st.checkbox(
                "✅ I understand the risks and potential consequences of this operation",
                key=f"risk_confirm_{operation}"
            ))
            
            if risk_level in [RiskLevel.HIGH, RiskLevel.CRITICAL]:
                confirmations.append(st.checkbox(
                    "✅ I have reviewed security policies and obtained necessary approvals",
                    key=f"policy_confirm_{operation}"
                ))
            
            if risk_level == RiskLevel.CRITICAL:
                confirmations.append(st.checkbox(
                    "✅ I have created appropriate backups and tested recovery procedures",
                    key=f"backup_confirm_{operation}"
                ))
            
            # 모든 확인사항이 체크되었는지 검증
            all_confirmed = all(confirmations)
            
            # 승인/거부 버튼
            col1, col2, col3 = st.columns([1, 1, 1])
            
            with col1:
                if st.button(
                    "❌ Cancel Operation",
                    type="secondary",
                    use_container_width=True,
                    key=f"cancel_{operation}"
                ):
                    st.session_state[f"approval_{operation}"] = False
                    st.error("Operation cancelled by user")
                    return False
            
            with col2:
                # 추가 정보 버튼
                if st.button(
                    "ℹ️ More Info",
                    use_container_width=True,
                    key=f"info_{operation}"
                ):
                    self.show_operation_details(operation, target, details)
            
            with col3:
                approve_button = st.button(
                    "✅ Approve & Execute",
                    type="primary",
                    disabled=not all_confirmed,
                    use_container_width=True,
                    key=f"approve_{operation}"
                )
                
                if approve_button and all_confirmed:
                    # 최종 확인
                    if self.final_confirmation_dialog(operation, risk_level):
                        st.session_state[f"approval_{operation}"] = True
                        st.success("Operation approved and queued for execution")
                        return True
            
            st.markdown("</div>", unsafe_allow_html=True)
        
        return False
    
    def final_confirmation_dialog(self, operation: str, risk_level: RiskLevel) -> bool:
        """최종 확인 다이얼로그"""
        if risk_level in [RiskLevel.HIGH, RiskLevel.CRITICAL]:
            
            # 최종 확인 모달 시뮬레이션
            st.markdown("### 🔐 Final Confirmation")
            
            confirmation_text = st.text_input(
                f"Type 'EXECUTE {operation.upper()}' to confirm:",
                key=f"final_confirm_{operation}",
                help="This is a final safety check for high-risk operations"
            )
            
            expected_text = f"EXECUTE {operation.upper()}"
            
            if confirmation_text == expected_text:
                return True
            elif confirmation_text:
                st.error("Confirmation text does not match. Please type exactly as shown.")
                return False
        
        return True
    
    def show_operation_details(self, operation: str, target: str, details: Dict[str, Any]):
        """작업 세부정보 표시"""
        with st.expander("📋 Detailed Operation Information", expanded=True):
            
            # 작업 설명
            operation_descriptions = {
                "network_scan": "Performs network reconnaissance to identify open ports and services",
                "vulnerability_scan": "Scans for known vulnerabilities and security weaknesses",
                "exploit_attempt": "Attempts to exploit identified vulnerabilities",
                "privilege_escalation": "Attempts to gain higher privileges on the target system"
            }
            
            description = operation_descriptions.get(
                operation.lower().replace(" ", "_"),
                "Custom security operation"
            )
            
            st.markdown(f"**Description:** {description}")
            
            # 기술적 세부사항
            st.markdown("**Technical Details:**")
            st.json(details)
            
            # 예상 실행 시간
            estimated_times = {
                "network_scan": "5-15 minutes",
                "vulnerability_scan": "15-60 minutes", 
                "exploit_attempt": "1-10 minutes",
                "privilege_escalation": "5-30 minutes"
            }
            
            estimated_time = estimated_times.get(
                operation.lower().replace(" ", "_"),
                "Variable"
            )
            
            st.markdown(f"**Estimated Duration:** {estimated_time}")
    
    def show_security_settings(self):
        """보안 설정 표시"""
        with st.sidebar:
            st.markdown("### 🔒 Security Settings")
            
            # 자동 승인 설정
            auto_approve_low = st.checkbox(
                "Auto-approve LOW risk operations",
                value=st.session_state.get("auto_approve_low", False),
                help="Automatically approve operations with low security risk"
            )
            
            # 알림 설정
            email_notifications = st.checkbox(
                "Email notifications for HIGH/CRITICAL operations",
                value=st.session_state.get("email_notifications", True)
            )
            
            # 승인 시간 제한
            approval_timeout = st.slider(
                "Approval timeout (minutes)",
                1, 60, 15,
                help="How long to wait for user approval before cancelling"
            )
            
            # 세션에 저장
            st.session_state.update({
                "auto_approve_low": auto_approve_low,
                "email_notifications": email_notifications,
                "approval_timeout": approval_timeout
            })

# 사용 예시
def demonstrate_security_approval():
    """보안 승인 시스템 데모"""
    st.header("🔐 Security Operation Approval System")
    
    approval_ui = SecurityApprovalUI()
    approval_ui.show_security_settings()
    
    # 데모 작업들
    demo_operations = {
        "Network Scan": {
            "risk": RiskLevel.LOW,
            "target": "192.168.1.100",
            "details": {
                "scan_type": "TCP SYN Scan",
                "port_range": "1-1000",
                "timeout": "30 seconds"
            },
            "warnings": []
        },
        "Vulnerability Assessment": {
            "risk": RiskLevel.MEDIUM,
            "target": "example.com",
            "details": {
                "scan_type": "CVE Database Check",
                "depth": "Standard",
                "tools": ["Nmap", "OpenVAS"]
            },
            "warnings": ["May trigger intrusion detection systems"]
        },
        "Exploit Attempt": {
            "risk": RiskLevel.HIGH,
            "target": "test-server.local",
            "details": {
                "exploit": "CVE-2024-1234",
                "payload": "Reverse Shell",
                "method": "Buffer Overflow"
            },
            "warnings": [
                "Will attempt to gain unauthorized access",
                "May crash target service",
                "Requires explicit written authorization"
            ]
        }
    }
    
    # 작업 선택
    selected_operation = st.selectbox(
        "Select Operation to Approve:",
        list(demo_operations.keys())
    )
    
    if st.button(f"Request Approval for {selected_operation}"):
        op_data = demo_operations[selected_operation]
        
        # 자동 승인 검사 (LOW 위험도만)
        if (op_data["risk"] == RiskLevel.LOW and 
            st.session_state.get("auto_approve_low", False)):
            st.success("✅ Operation auto-approved (LOW risk)")
        else:
            # 승인 다이얼로그 표시
            approved = approval_ui.show_approval_dialog(
                operation=selected_operation,
                target=op_data["target"],
                risk_level=op_data["risk"],
                details=op_data["details"],
                warnings=op_data["warnings"]
            )
            
            if approved:
                st.balloons()
]]></correct-example>
<incorrect-example title="자동 실행" conditions="위험한 보안 작업 실행" expected-result="명시적 사용자 승인" incorrectness-criteria="사용자 승인 없는 자동 실행"><![CDATA[
def auto_execute_operation(operation: str, target: str):
    """자동 실행 (위험)"""
    # 사용자 승인이나 위험도 평가 없이 바로 실행
    if st.button(f"Execute {operation}"):
        execute_security_operation(operation, target)
        st.success("Operation completed")
]]></incorrect-example>
</example>
</examples>
</non-negotiable>
</requirements>

<context description="CLI 및 웹 인터페이스 컨텍스트">
Decepticon의 사용자 인터페이스는 보안 전문가들이 복잡한 AI 기반 레드팀 테스팅을 효율적으로 수행할 수 있도록 도와야 합니다.
CLI는 자동화와 스크립팅에 적합하고, 웹 인터페이스는 대화형 작업과 시각적 분석에 최적화되어야 합니다.
보안 작업의 특성상 사용자의 명시적 승인과 충분한 정보 제공이 필수적입니다.
</context>

<references>
<reference as="dependency" href=".cursor/rules/main-project-rules.mdc" reason="기본 프로젝트 규칙">메인 프로젝트 규칙</reference>
<reference as="context" href=".cursor/rules/security-pentesting.mdc" reason="보안 작업 승인">보안 및 펜테스팅 규칙</reference>
<reference as="context" href=".cursor/rules/error-handling.mdc" reason="UI 에러 처리">에러 처리 및 예외 관리</reference>
</references>
</rule>
