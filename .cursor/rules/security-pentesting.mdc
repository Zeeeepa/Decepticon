---
description: 보안 및 펜테스팅 도구 개발을 위한 안전성과 윤리적 가이드라인
globs: "src/tools/**/*.py"
alwaysApply: false
---

<rule>
<meta>
<title>Security and Penetration Testing Development Standards</title>
<description>보안 테스팅 도구 개발을 위한 안전성, 윤리적 가이드라인 및 모범 사례</description>
<created-at utc-timestamp="1720684800">2025-07-08, 11:30 AM KST</created-at>
<last-updated-at utc-timestamp="1720684800">2025-07-08, 11:30 AM KST</last-updated-at>
<applies-to>
<file-matcher glob="src/tools/**/*.py">보안 도구 관련 파일</file-matcher>
<file-matcher glob="src/agents/**/*.py">보안 에이전트 파일</file-matcher>
<action-matcher action="security-tool">보안 도구 개발 시</action-matcher>
</applies-to>
</meta>

<requirements>
<requirement priority="critical">
<description>모든 보안 도구는 타겟 검증과 사용자 승인을 거쳐야 한다.</description>
<examples>
<example title="타겟 검증 시스템">
<correct-example title="안전한 타겟 검증" conditions="보안 도구 실행" expected-result="승인된 타겟에서만 실행" correctness-criteria="IP 범위 검증과 사용자 승인"><![CDATA[
from ipaddress import ip_address, ip_network
from typing import List, Dict, Any, Optional
import re

class PenetrationTestingValidator:
    """펜테스팅 도구 검증 시스템"""
    
    def __init__(self):
        # 허용된 내부 네트워크 범위
        self.allowed_networks = [
            ip_network("192.168.0.0/16"),    # 사설 IP Class C
            ip_network("10.0.0.0/8"),        # 사설 IP Class A  
            ip_network("172.16.0.0/12"),     # 사설 IP Class B
            ip_network("127.0.0.0/8")        # 로컬호스트
        ]
        
        # 금지된 도구들 (파괴적 행위)
        self.destructive_tools = [
            "format_disk", "delete_files", "shutdown_system",
            "corrupt_data", "ddos_attack", "spam_email"
        ]
        
        # 높은 위험도 도구들 (승인 필요)
        self.high_risk_tools = [
            "metasploit_exploit", "privilege_escalation",
            "credential_attack", "payload_execution"
        ]
    
    def validate_target(self, target: str) -> Dict[str, Any]:
        """타겟 주소 검증"""
        try:
            # IP 주소 검증
            target_ip = ip_address(target)
            
            # 허용된 네트워크 범위 내인지 확인
            is_allowed = any(target_ip in network for network in self.allowed_networks)
            
            if not is_allowed:
                return {
                    "valid": False,
                    "reason": f"Target {target} is outside allowed network ranges",
                    "allowed_networks": [str(net) for net in self.allowed_networks]
                }
            
            # 특별히 위험한 주소 체크
            if target_ip.is_multicast or target_ip.is_reserved:
                return {
                    "valid": False,
                    "reason": f"Target {target} is a multicast or reserved address"
                }
            
            return {"valid": True, "target_type": "ip", "address": str(target_ip)}
            
        except ValueError:
            # 도메인 이름인 경우
            if self._is_valid_domain(target):
                return {"valid": True, "target_type": "domain", "address": target}
            else:
                return {
                    "valid": False,
                    "reason": f"Invalid target format: {target}"
                }
    
    def _is_valid_domain(self, domain: str) -> bool:
        """도메인 이름 유효성 검증"""
        pattern = r'^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$'
        return bool(re.match(pattern, domain)) and len(domain) <= 253
    
    def assess_tool_risk(self, tool_name: str) -> Dict[str, Any]:
        """도구 위험도 평가"""
        if tool_name in self.destructive_tools:
            return {
                "risk_level": "DESTRUCTIVE",
                "allowed": False,
                "reason": "Destructive tool is not allowed"
            }
        
        if tool_name in self.high_risk_tools:
            return {
                "risk_level": "HIGH", 
                "allowed": True,
                "approval_required": True,
                "reason": "High-risk tool requires user approval"
            }
        
        return {
            "risk_level": "MEDIUM",
            "allowed": True,
            "approval_required": False,
            "reason": "Standard penetration testing tool"
        }

async def execute_security_tool_safely(
    tool_name: str,
    target: str,
    user_id: str,
    **kwargs
) -> Dict[str, Any]:
    """보안 도구 안전 실행"""
    validator = PenetrationTestingValidator()
    
    # 1. 타겟 검증
    target_validation = validator.validate_target(target)
    if not target_validation["valid"]:
        return {
            "status": "blocked",
            "reason": target_validation["reason"],
            "validation_details": target_validation
        }
    
    # 2. 도구 위험도 평가
    risk_assessment = validator.assess_tool_risk(tool_name)
    if not risk_assessment["allowed"]:
        return {
            "status": "blocked",
            "reason": risk_assessment["reason"],
            "risk_assessment": risk_assessment
        }
    
    # 3. 높은 위험도 도구는 사용자 승인 필요
    if risk_assessment.get("approval_required", False):
        approval = await request_user_approval(
            tool_name, target, risk_assessment, user_id
        )
        if not approval:
            return {
                "status": "denied",
                "reason": "User denied approval for high-risk tool",
                "risk_assessment": risk_assessment
            }
    
    # 4. 승인된 경우 도구 실행
    try:
        result = await execute_tool_with_monitoring(tool_name, target, **kwargs)
        
        # 5. 실행 로그 기록
        await log_security_operation(
            tool_name, target, "success", user_id, result
        )
        
        return {
            "status": "completed",
            "result": result,
            "target_validation": target_validation,
            "risk_assessment": risk_assessment
        }
    
    except Exception as e:
        await log_security_operation(
            tool_name, target, "failed", user_id, str(e)
        )
        
        return {
            "status": "failed",
            "error": str(e),
            "risk_assessment": risk_assessment
        }
]]></correct-example>
<incorrect-example title="검증 없는 도구 실행" conditions="보안 도구 실행" expected-result="승인된 타겟에서만 실행" incorrectness-criteria="타겟 검증과 승인 과정 누락"><![CDATA[
async def execute_security_tool_unsafe(tool_name: str, target: str, **kwargs) -> Any:
    """검증 없는 위험한 도구 실행"""
    # 타겟 검증, 위험도 평가, 사용자 승인 없이 바로 실행
    result = await some_security_tool.execute(target=target, **kwargs)
    return result
]]></incorrect-example>
</example>
</examples>
</requirement>

<requirement priority="high">
<description>CVE 데이터베이스와 취약점 정보는 신뢰할 수 있는 소스에서만 가져온다.</description>
<examples>
<example title="CVE 데이터 소싱">
<correct-example title="신뢰할 수 있는 CVE 소스" conditions="취약점 정보 조회" expected-result="정확한 취약점 데이터" correctness-criteria="공식 CVE 데이터베이스 사용"><![CDATA[
import aiohttp
from typing import Dict, Any, List
from dataclasses import dataclass
from datetime import datetime

@dataclass
class CVEInfo:
    """CVE 정보 구조체"""
    id: str
    description: str
    severity: str
    cvss_score: float
    published_date: str
    last_modified: str
    affected_products: List[str]
    references: List[str]

class TrustedCVESource:
    """신뢰할 수 있는 CVE 데이터 소스"""
    
    def __init__(self):
        # 공식 CVE 데이터베이스 URL들
        self.official_sources = {
            "nvd": "https://services.nvd.nist.gov/rest/json/cves/2.0",
            "mitre": "https://cve.mitre.org/data/downloads",
            "first": "https://www.first.org/cvss/calculator"
        }
        
        # API 키들 (환경변수에서 로드)
        self.api_keys = {
            "nvd": os.getenv("NVD_API_KEY"),
            "cve_details": os.getenv("CVE_DETAILS_API_KEY")
        }
    
    async def get_cve_info(self, cve_id: str) -> Optional[CVEInfo]:
        """공식 소스에서 CVE 정보 조회"""
        try:
            # CVE ID 형식 검증
            if not self._is_valid_cve_id(cve_id):
                raise ValueError(f"Invalid CVE ID format: {cve_id}")
            
            # NVD API에서 정보 조회
            cve_data = await self._fetch_from_nvd(cve_id)
            
            if cve_data:
                return self._parse_nvd_response(cve_data)
            
            return None
            
        except Exception as e:
            print(f"Error fetching CVE {cve_id}: {e}")
            return None
    
    def _is_valid_cve_id(self, cve_id: str) -> bool:
        """CVE ID 형식 검증 (CVE-YYYY-NNNN...)"""
        import re
        pattern = r'^CVE-\d{4}-\d{4,}$'
        return bool(re.match(pattern, cve_id))
    
    async def _fetch_from_nvd(self, cve_id: str) -> Optional[Dict[str, Any]]:
        """NVD API에서 CVE 데이터 조회"""
        url = f"{self.official_sources['nvd']}?cveId={cve_id}"
        
        headers = {}
        if self.api_keys["nvd"]:
            headers["apiKey"] = self.api_keys["nvd"]
        
        async with aiohttp.ClientSession() as session:
            async with session.get(url, headers=headers) as response:
                if response.status == 200:
                    data = await response.json()
                    
                    if data.get("vulnerabilities"):
                        return data["vulnerabilities"][0]
                
                return None
    
    def _parse_nvd_response(self, cve_data: Dict[str, Any]) -> CVEInfo:
        """NVD 응답 데이터 파싱"""
        cve = cve_data["cve"]
        
        # CVSS 점수 추출
        cvss_score = 0.0
        severity = "UNKNOWN"
        
        if "metrics" in cve:
            metrics = cve["metrics"]
            if "cvssMetricV31" in metrics:
                cvss_data = metrics["cvssMetricV31"][0]["cvssData"]
                cvss_score = cvss_data["baseScore"]
                severity = cvss_data["baseSeverity"]
            elif "cvssMetricV30" in metrics:
                cvss_data = metrics["cvssMetricV30"][0]["cvssData"]
                cvss_score = cvss_data["baseScore"] 
                severity = cvss_data["baseSeverity"]
        
        # 영향받는 제품 추출
        affected_products = []
        if "configurations" in cve:
            for config in cve["configurations"]:
                for node in config.get("nodes", []):
                    for cpe_match in node.get("cpeMatch", []):
                        if cpe_match.get("vulnerable", False):
                            affected_products.append(cpe_match["criteria"])
        
        # 참조 링크 추출
        references = []
        if "references" in cve:
            references = [ref["url"] for ref in cve["references"]]
        
        return CVEInfo(
            id=cve["id"],
            description=cve["descriptions"][0]["value"],
            severity=severity,
            cvss_score=cvss_score,
            published_date=cve["published"],
            last_modified=cve["lastModified"],
            affected_products=affected_products,
            references=references
        )

# 글로벌 CVE 소스 인스턴스
_cve_source = TrustedCVESource()

async def get_vulnerability_info(cve_id: str) -> Optional[CVEInfo]:
    """신뢰할 수 있는 소스에서 취약점 정보 조회"""
    return await _cve_source.get_cve_info(cve_id)
]]></correct-example>
<incorrect-example title="신뢰할 수 없는 소스 사용" conditions="취약점 정보 조회" expected-result="정확한 취약점 데이터" incorrectness-criteria="비공식 소스나 검증되지 않은 데이터"><![CDATA[
async def get_vulnerability_info_unsafe(cve_id: str) -> Dict[str, Any]:
    """신뢰할 수 없는 소스에서 데이터 조회"""
    # 검증되지 않은 소스에서 데이터 조회
    url = f"https://random-cve-site.com/api/{cve_id}"
    
    # API 키나 인증 없이 조회
    async with aiohttp.ClientSession() as session:
        async with session.get(url) as response:
            data = await response.json()
            return data  # 데이터 검증 없이 반환
]]></incorrect-example>
</example>
</examples>
</requirement>

<requirement priority="high">
<description>네트워크 스캔과 포트 스캔은 적절한 속도 제한과 타임아웃을 적용한다.</description>
<examples>
<example title="안전한 네트워크 스캔">
<correct-example title="속도 제한이 있는 스캔" conditions="네트워크 스캔 실행" expected-result="안전한 스캔 속도" correctness-criteria="속도 제한과 타임아웃 적용"><![CDATA[
import asyncio
import socket
from typing import List, Dict, Any, AsyncGenerator
from dataclasses import dataclass
import time

@dataclass 
class ScanConfig:
    """스캔 설정"""
    delay_between_scans: float = 0.1  # 스캔 간 지연 (초)
    timeout_per_port: float = 3.0     # 포트당 타임아웃 (초)
    max_concurrent_scans: int = 10    # 최대 동시 스캔 수
    max_ports_per_target: int = 1000  # 타겟당 최대 포트 수

class ResponsibleScanner:
    """책임감 있는 네트워크 스캐너"""
    
    def __init__(self, config: ScanConfig = None):
        self.config = config or ScanConfig()
        self.scan_semaphore = asyncio.Semaphore(self.config.max_concurrent_scans)
    
    async def scan_ports(
        self, 
        target: str, 
        ports: List[int]
    ) -> AsyncGenerator[Dict[str, Any], None]:
        """포트 스캔 (속도 제한 적용)"""
        
        # 포트 수 제한 검사
        if len(ports) > self.config.max_ports_per_target:
            raise ValueError(f"Too many ports requested: {len(ports)} > {self.config.max_ports_per_target}")
        
        scan_start_time = time.time()
        
        for i, port in enumerate(ports):
            async with self.scan_semaphore:
                try:
                    # 포트 스캔 실행
                    result = await self._scan_single_port(target, port)
                    
                    yield {
                        "target": target,
                        "port": port,
                        "status": result["status"],
                        "service": result.get("service"),
                        "scan_time": result["scan_time"],
                        "progress": f"{i+1}/{len(ports)}"
                    }
                    
                    # 스캔 간 지연 적용 (마지막 포트 제외)
                    if i < len(ports) - 1:
                        await asyncio.sleep(self.config.delay_between_scans)
                
                except Exception as e:
                    yield {
                        "target": target,
                        "port": port,
                        "status": "error",
                        "error": str(e),
                        "progress": f"{i+1}/{len(ports)}"
                    }
        
        total_time = time.time() - scan_start_time
        yield {
            "target": target,
            "status": "completed",
            "total_ports": len(ports),
            "total_time": total_time,
            "average_time_per_port": total_time / len(ports)
        }
    
    async def _scan_single_port(self, target: str, port: int) -> Dict[str, Any]:
        """개별 포트 스캔"""
        start_time = time.time()
        
        try:
            # 타임아웃과 함께 소켓 연결 시도
            future = asyncio.create_task(self._connect_to_port(target, port))
            result = await asyncio.wait_for(future, timeout=self.config.timeout_per_port)
            
            scan_time = time.time() - start_time
            
            if result:
                # 서비스 탐지 시도
                service = await self._detect_service(target, port)
                return {
                    "status": "open",
                    "service": service,
                    "scan_time": scan_time
                }
            else:
                return {
                    "status": "closed",
                    "scan_time": scan_time
                }
        
        except asyncio.TimeoutError:
            return {
                "status": "filtered",
                "scan_time": self.config.timeout_per_port
            }
        except Exception as e:
            return {
                "status": "error",
                "error": str(e),
                "scan_time": time.time() - start_time
            }
    
    async def _connect_to_port(self, target: str, port: int) -> bool:
        """포트 연결 시도"""
        try:
            reader, writer = await asyncio.open_connection(target, port)
            writer.close()
            await writer.wait_closed()
            return True
        except:
            return False
    
    async def _detect_service(self, target: str, port: int) -> Optional[str]:
        """간단한 서비스 탐지"""
        common_services = {
            22: "SSH",
            23: "Telnet", 
            25: "SMTP",
            53: "DNS",
            80: "HTTP",
            110: "POP3",
            143: "IMAP",
            443: "HTTPS",
            993: "IMAPS",
            995: "POP3S"
        }
        
        return common_services.get(port, "Unknown")

async def perform_responsible_scan(target: str, port_range: str) -> List[Dict[str, Any]]:
    """책임감 있는 스캔 실행"""
    scanner = ResponsibleScanner()
    
    # 포트 범위 파싱
    ports = parse_port_range(port_range)
    
    results = []
    async for result in scanner.scan_ports(target, ports):
        results.append(result)
        
        # 진행상황 표시
        if "progress" in result:
            print(f"스캔 진행: {result['progress']} - Port {result.get('port', '')}: {result.get('status', '')}")
    
    return results

def parse_port_range(port_range: str) -> List[int]:
    """포트 범위 문자열을 포트 리스트로 변환"""
    ports = []
    
    for part in port_range.split(','):
        if '-' in part:
            start, end = map(int, part.split('-'))
            ports.extend(range(start, end + 1))
        else:
            ports.append(int(part))
    
    return sorted(list(set(ports)))  # 중복 제거 및 정렬
]]></correct-example>
<incorrect-example title="무제한 속도 스캔" conditions="네트워크 스캔 실행" expected-result="안전한 스캔 속도" incorrectness-criteria="속도 제한 없는 aggressive 스캔"><![CDATA[
async def aggressive_scan(target: str, ports: List[int]) -> List[Dict[str, Any]]:
    """제한 없는 aggressive 스캔 (위험)"""
    results = []
    
    # 모든 포트를 동시에 스캔 (네트워크 부하 유발)
    tasks = []
    for port in ports:
        task = scan_port_no_limit(target, port)
        tasks.append(task)
    
    # 타임아웃이나 지연 없이 모든 스캔 동시 실행
    results = await asyncio.gather(*tasks)
    return results
]]></incorrect-example>
</example>
</examples>
</requirement>

<non-negotiable priority="critical">
<description>익스플로잇 코드는 교육 목적으로만 사용하며, 실제 공격에 사용하지 않는다.</description>
<examples>
<example title="윤리적 익스플로잇 사용">
<correct-example title="교육용 익스플로잇 구현" conditions="익스플로잇 도구 개발" expected-result="윤리적 사용" correctness-criteria="명확한 교육 목적과 안전 장치"><![CDATA[
from enum import Enum
from typing import Dict, Any, Optional
import warnings

class ExploitPurpose(Enum):
    """익스플로잇 사용 목적"""
    EDUCATION = "education"
    AUTHORIZED_TESTING = "authorized_testing"
    VULNERABILITY_RESEARCH = "vulnerability_research"

class EthicalExploitFramework:
    """윤리적 익스플로잇 프레임워크"""
    
    def __init__(self):
        self.educational_disclaimer = """
        🚨 EDUCATIONAL PURPOSE ONLY 🚨
        
        This exploit is provided for educational and authorized testing purposes only.
        Unauthorized use of this code for malicious purposes is strictly prohibited
        and may violate applicable laws.
        
        By using this code, you agree to:
        1. Use it only in authorized testing environments
        2. Not use it for illegal activities
        3. Respect the privacy and security of others
        4. Follow responsible disclosure practices
        """
    
    def create_educational_exploit(
        self,
        exploit_name: str,
        target_vulnerability: str,
        purpose: ExploitPurpose,
        authorization_info: Dict[str, str]
    ) -> Dict[str, Any]:
        """교육용 익스플로잇 생성"""
        
        # 목적 검증
        if purpose not in ExploitPurpose:
            raise ValueError("Invalid exploit purpose")
        
        # 권한 정보 검증
        required_fields = ["target_owner", "permission_document", "test_scope"]
        for field in required_fields:
            if field not in authorization_info:
                raise ValueError(f"Missing authorization field: {field}")
        
        # 교육용 면책조항 표시
        print(self.educational_disclaimer)
        
        exploit_info = {
            "name": exploit_name,
            "vulnerability": target_vulnerability,
            "purpose": purpose.value,
            "authorization": authorization_info,
            "created_at": datetime.now().isoformat(),
            "educational_only": True,
            "disclaimer_shown": True
        }
        
        return exploit_info
    
    def execute_authorized_test(
        self,
        exploit_info: Dict[str, Any],
        target: str,
        test_parameters: Dict[str, Any]
    ) -> Dict[str, Any]:
        """승인된 테스트 실행"""
        
        # 교육용 확인
        if not exploit_info.get("educational_only", False):
            raise ValueError("Only educational exploits are allowed")
        
        # 타겟 검증
        if not self._verify_authorized_target(target, exploit_info["authorization"]):
            raise ValueError("Target is not authorized for testing")
        
        # 안전 모드에서 실행
        warnings.warn(
            "Executing exploit in educational mode. Real vulnerabilities will not be exploited.",
            UserWarning
        )
        
        # 실제로는 시뮬레이션만 수행
        simulation_result = self._simulate_exploit(exploit_info, target, test_parameters)
        
        return {
            "status": "simulation_completed",
            "exploit": exploit_info["name"],
            "target": target,
            "simulation_result": simulation_result,
            "note": "This was a simulation for educational purposes"
        }
    
    def _verify_authorized_target(self, target: str, authorization: Dict[str, str]) -> bool:
        """승인된 타겟인지 검증"""
        # 실제 구현에서는 더 정교한 검증 로직 필요
        return authorization.get("target_owner") != "unknown"
    
    def _simulate_exploit(
        self, 
        exploit_info: Dict[str, Any], 
        target: str, 
        parameters: Dict[str, Any]
    ) -> Dict[str, Any]:
        """익스플로잇 시뮬레이션 (실제 공격 안함)"""
        return {
            "vulnerability_confirmed": True,
            "exploit_would_succeed": True,
            "impact_assessment": "High - System compromise possible",
            "mitigation_recommendations": [
                "Update affected software",
                "Apply security patches",
                "Implement network segmentation"
            ],
            "educational_notes": "This exploit demonstrates the importance of keeping software updated"
        }

# 교육용 익스플로잇 사용 예시
async def demonstrate_vulnerability_assessment():
    """취약점 평가 시연"""
    framework = EthicalExploitFramework()
    
    # 승인 정보 설정
    authorization = {
        "target_owner": "Security Testing Lab",
        "permission_document": "Test Authorization #2025-001",
        "test_scope": "Internal network penetration testing",
        "expiry_date": "2025-12-31"
    }
    
    # 교육용 익스플로잇 생성
    exploit = framework.create_educational_exploit(
        exploit_name="CVE-2024-1234 Buffer Overflow Demo",
        target_vulnerability="CVE-2024-1234",
        purpose=ExploitPurpose.EDUCATION,
        authorization_info=authorization
    )
    
    # 승인된 테스트 실행
    result = framework.execute_authorized_test(
        exploit_info=exploit,
        target="192.168.1.100",
        test_parameters={"timeout": 30, "safe_mode": True}
    )
    
    return result
]]></correct-example>
<incorrect-example title="무제한 익스플로잇 도구" conditions="익스플로잇 도구 개발" expected-result="윤리적 사용" incorrectness-criteria="안전 장치 없는 공격 도구"><![CDATA[
def create_attack_tool(target: str, exploit_type: str) -> Any:
    """제한 없는 공격 도구 (위험)"""
    # 교육 목적, 승인 확인, 안전 장치 없이 바로 공격 도구 생성
    attack_payload = generate_malicious_payload(exploit_type)
    return execute_attack(target, attack_payload)
]]></incorrect-example>
</example>
</examples>
</non-negotiable>
</requirements>

<context description="보안 및 펜테스팅 컨텍스트">
Decepticon은 AI 기반 레드팀 테스팅 프레임워크로서, 보안 도구들을 윤리적이고 책임감 있게 사용해야 합니다.
모든 보안 테스팅은 명시적인 승인 하에 이루어지며, 교육과 방어 향상을 목적으로 합니다.
실제 공격이나 악의적인 목적으로 사용되어서는 안 되며, 항상 합법적인 범위 내에서 동작해야 합니다.
</context>

<references>
<reference as="dependency" href=".cursor/rules/main-project-rules.mdc" reason="기본 프로젝트 규칙">메인 프로젝트 규칙</reference>
<reference as="context" href=".cursor/rules/mcp-integration.mdc" reason="보안 도구 MCP 통합">MCP 통합 규칙</reference>
<reference as="context" href=".cursor/rules/ai-agents.mdc" reason="보안 에이전트 개발">AI 에이전트 개발 규칙</reference>
</references>
</rule>
