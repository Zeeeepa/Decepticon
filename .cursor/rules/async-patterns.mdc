---
description: 비동기 프로그래밍 패턴과 성능 최적화 규칙
globs: "**/*.py"
alwaysApply: false
---

<rule>
<meta>
<title>Async Programming Patterns and Performance</title>
<description>Python 비동기 프로그래밍의 모범 사례와 성능 최적화 기법</description>
<created-at utc-timestamp="1720684800">2025-07-08, 11:10 AM KST</created-at>
<last-updated-at utc-timestamp="1720684800">2025-07-08, 11:10 AM KST</last-updated-at>
<applies-to>
<file-matcher glob="**/*.py">비동기 함수가 포함된 모든 Python 파일</file-matcher>
<action-matcher action="async-function">비동기 함수 작성 시</action-matcher>
</applies-to>
</meta>

<requirements>
<requirement priority="critical">
<description>모든 비동기 함수는 async/await 키워드를 올바르게 사용하고, I/O 바운드 작업에만 적용한다.</description>
<examples>
<example title="올바른 async/await 사용">
<correct-example title="I/O 바운드 작업의 비동기 처리" conditions="네트워크 요청이나 파일 I/O" expected-result="비블로킹 실행" correctness-criteria="await 키워드로 비동기 호출"><![CDATA[
import asyncio
import aiohttp
from typing import List, Dict, Any

async def fetch_vulnerability_data(targets: List[str]) -> Dict[str, Any]:
    """여러 타겟의 취약점 데이터를 비동기로 수집"""
    results = {}
    
    async with aiohttp.ClientSession() as session:
        tasks = []
        for target in targets:
            task = fetch_single_target(session, target)
            tasks.append(task)
        
        # 모든 요청을 동시에 실행
        responses = await asyncio.gather(*tasks, return_exceptions=True)
        
        for target, response in zip(targets, responses):
            if isinstance(response, Exception):
                results[target] = {"error": str(response)}
            else:
                results[target] = response
    
    return results

async def fetch_single_target(session: aiohttp.ClientSession, target: str) -> Dict[str, Any]:
    """개별 타겟 데이터 수집"""
    try:
        async with session.get(f"https://api.example.com/scan/{target}") as response:
            data = await response.json()
            return data
    except Exception as e:
        raise Exception(f"Failed to fetch {target}: {e}")
]]></correct-example>
<incorrect-example title="불필요한 비동기 사용" conditions="CPU 바운드 작업" expected-result="적절한 동기 처리" incorrectness-criteria="CPU 작업에 async 사용"><![CDATA[
async def calculate_risk_score(vulnerabilities: List[Dict]) -> float:
    """CPU 집약적 작업에 불필요한 async 사용"""
    total_score = 0
    for vuln in vulnerabilities:
        # CPU 바운드 계산에 async는 오버헤드만 증가
        score = vuln['severity'] * vuln['exploitability']
        total_score += score
    return total_score / len(vulnerabilities)
]]></incorrect-example>
</example>
</examples>
</requirement>

<requirement priority="high">
<description>여러 비동기 작업을 처리할 때는 asyncio.gather()나 asyncio.as_completed()를 적절히 사용한다.</description>
<examples>
<example title="동시 실행 패턴">
<correct-example title="asyncio.gather를 사용한 동시 실행" conditions="여러 독립적인 비동기 작업" expected-result="병렬 처리로 성능 향상" correctness-criteria="gather나 as_completed 사용"><![CDATA[
async def execute_parallel_scans(targets: List[str]) -> Dict[str, Any]:
    """여러 타겟을 병렬로 스캔"""
    # 모든 스캔이 완료될 때까지 대기 (실패해도 계속)
    scan_tasks = [scan_single_target(target) for target in targets]
    results = await asyncio.gather(*scan_tasks, return_exceptions=True)
    
    # 결과 정리
    scan_results = {}
    for target, result in zip(targets, results):
        if isinstance(result, Exception):
            scan_results[target] = {"status": "error", "message": str(result)}
        else:
            scan_results[target] = {"status": "success", "data": result}
    
    return scan_results

async def process_scans_as_completed(targets: List[str]) -> None:
    """스캔 완료 순서대로 처리"""
    scan_tasks = [scan_single_target(target) for target in targets]
    
    # 완료되는 순서대로 결과 처리
    for completed_task in asyncio.as_completed(scan_tasks):
        try:
            result = await completed_task
            print(f"스캔 완료: {result['target']}")
            await process_scan_result(result)
        except Exception as e:
            print(f"스캔 실패: {e}")
]]></correct-example>
<incorrect-example title="순차 실행" conditions="여러 독립적인 비동기 작업" expected-result="병렬 처리로 성능 향상" incorrectness-criteria="불필요한 순차 실행"><![CDATA[
async def execute_sequential_scans(targets: List[str]) -> Dict[str, Any]:
    """비효율적인 순차 실행"""
    scan_results = {}
    
    # 각 스캔을 순차적으로 실행 (병렬화 기회 낭비)
    for target in targets:
        try:
            result = await scan_single_target(target)
            scan_results[target] = {"status": "success", "data": result}
        except Exception as e:
            scan_results[target] = {"status": "error", "message": str(e)}
    
    return scan_results
]]></incorrect-example>
</example>
</examples>
</requirement>

<requirement priority="high">
<description>비동기 컨텍스트 매니저를 사용하여 리소스를 안전하게 관리한다.</description>
<examples>
<example title="비동기 컨텍스트 매니저">
<correct-example title="async with를 사용한 리소스 관리" conditions="외부 리소스 연결" expected-result="안전한 리소스 해제" correctness-criteria="async with 사용"><![CDATA[
import aiofiles
from contextlib import asynccontextmanager

@asynccontextmanager
async def mcp_client_session(config: Dict[str, Any]):
    """MCP 클라이언트 세션 관리"""
    client = None
    try:
        client = MultiServerMCPClient(config)
        await client.connect()
        yield client
    except Exception as e:
        print(f"MCP 클라이언트 오류: {e}")
        raise
    finally:
        if client:
            await client.disconnect()

async def load_scan_results_safely(file_path: str) -> Dict[str, Any]:
    """파일을 안전하게 비동기 로드"""
    try:
        async with aiofiles.open(file_path, 'r') as file:
            content = await file.read()
            return json.loads(content)
    except Exception as e:
        print(f"파일 로드 실패: {e}")
        return {}

async def execute_with_mcp_tools(config: Dict[str, Any], task: str) -> Any:
    """MCP 도구를 안전하게 사용"""
    async with mcp_client_session(config) as client:
        tools = await client.get_tools()
        result = await execute_task_with_tools(tools, task)
        return result
]]></correct-example>
<incorrect-example title="수동 리소스 관리" conditions="외부 리소스 연결" expected-result="안전한 리소스 해제" incorrectness-criteria="수동 cleanup"><![CDATA[
async def execute_with_mcp_tools_unsafe(config: Dict[str, Any], task: str) -> Any:
    """수동 리소스 관리 (위험)"""
    client = MultiServerMCPClient(config)
    await client.connect()
    
    try:
        tools = await client.get_tools()
        result = await execute_task_with_tools(tools, task)
        return result
    except Exception as e:
        # 예외 발생 시 disconnect가 호출되지 않을 수 있음
        print(f"오류 발생: {e}")
        raise
    finally:
        # finally 블록이 있어도 컨텍스트 매니저가 더 안전
        await client.disconnect()
]]></incorrect-example>
</example>
</examples>
</requirement>

<requirement priority="medium">
<description>비동기 제너레이터를 사용하여 스트리밍 데이터를 효율적으로 처리한다.</description>
<examples>
<example title="비동기 제너레이터 사용">
<correct-example title="스트리밍 데이터 처리" conditions="대용량 데이터나 실시간 스트림" expected-result="메모리 효율적인 처리" correctness-criteria="async generator 사용"><![CDATA[
from typing import AsyncGenerator

async def stream_scan_results(targets: List[str]) -> AsyncGenerator[Dict[str, Any], None]:
    """스캔 결과를 스트리밍으로 반환"""
    for target in targets:
        try:
            # 스캔 실행
            scan_result = await scan_single_target(target)
            
            # 결과를 즉시 yield (메모리 효율적)
            yield {
                "target": target,
                "status": "completed",
                "result": scan_result,
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            yield {
                "target": target,
                "status": "error", 
                "error": str(e),
                "timestamp": datetime.now().isoformat()
            }

async def process_streaming_results():
    """스트리밍 결과 처리"""
    targets = ["192.168.1.1", "192.168.1.2", "192.168.1.3"]
    
    # 비동기 제너레이터 사용
    async for result in stream_scan_results(targets):
        # 결과가 나오는 즉시 처리
        if result["status"] == "completed":
            await save_scan_result(result)
            print(f"✅ {result['target']} 스캔 완료")
        else:
            print(f"❌ {result['target']} 스캔 실패: {result['error']}")
]]></correct-example>
<incorrect-example title="전체 결과를 메모리에 로드" conditions="대용량 데이터나 실시간 스트림" expected-result="메모리 효율적인 처리" incorrectness-criteria="모든 데이터를 메모리에 저장"><![CDATA[
async def collect_all_scan_results(targets: List[str]) -> List[Dict[str, Any]]:
    """모든 결과를 메모리에 수집 (비효율적)"""
    all_results = []
    
    for target in targets:
        try:
            scan_result = await scan_single_target(target)
            all_results.append({
                "target": target,
                "status": "completed",
                "result": scan_result
            })
        except Exception as e:
            all_results.append({
                "target": target,
                "status": "error",
                "error": str(e)
            })
    
    # 모든 결과를 메모리에 유지 (대용량 데이터 시 문제)
    return all_results
]]></incorrect-example>
</example>
</examples>
</requirement>

<non-negotiable priority="critical">
<description>비동기 함수에서는 절대로 동기 I/O 함수를 직접 호출하지 않는다.</description>
<examples>
<example title="비동기 함수에서의 I/O 처리">
<correct-example title="비동기 I/O 함수 사용" conditions="비동기 함수 내 I/O 작업" expected-result="비블로킹 실행" correctness-criteria="aiofiles, aiohttp 등 비동기 라이브러리 사용"><![CDATA[
import aiofiles
import aiohttp
import asyncio

async def save_scan_report_async(report_data: Dict[str, Any], file_path: str) -> None:
    """비동기적으로 리포트 저장"""
    try:
        # aiofiles를 사용한 비동기 파일 쓰기
        async with aiofiles.open(file_path, 'w') as file:
            await file.write(json.dumps(report_data, indent=2))
        
        print(f"리포트 저장 완료: {file_path}")
        
    except Exception as e:
        print(f"리포트 저장 실패: {e}")

async def fetch_cve_data_async(cve_id: str) -> Dict[str, Any]:
    """CVE 데이터 비동기 조회"""
    url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
    
    try:
        # aiohttp를 사용한 비동기 HTTP 요청
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                data = await response.json()
                return data
                
    except Exception as e:
        print(f"CVE 데이터 조회 실패: {e}")
        return {}
]]></correct-example>
<incorrect-example title="동기 I/O 함수 사용" conditions="비동기 함수 내 I/O 작업" expected-result="비블로킹 실행" incorrectness-criteria="동기 I/O 라이브러리 사용"><![CDATA[
import requests
import json

async def save_scan_report_blocking(report_data: Dict[str, Any], file_path: str) -> None:
    """동기 I/O로 인한 블로킹 (잘못된 예)"""
    try:
        # 동기 파일 쓰기 - 이벤트 루프를 블로킹함
        with open(file_path, 'w') as file:
            file.write(json.dumps(report_data, indent=2))
        
        print(f"리포트 저장 완료: {file_path}")
        
    except Exception as e:
        print(f"리포트 저장 실패: {e}")

async def fetch_cve_data_blocking(cve_id: str) -> Dict[str, Any]:
    """동기 HTTP 요청으로 인한 블로킹 (잘못된 예)"""
    url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
    
    try:
        # 동기 HTTP 요청 - 이벤트 루프를 블로킹함
        response = requests.get(url)
        data = response.json()
        return data
        
    except Exception as e:
        print(f"CVE 데이터 조회 실패: {e}")
        return {}
]]></incorrect-example>
</example>
</examples>
</non-negotiable>
</requirements>

<context description="비동기 프로그래밍 컨텍스트">
Decepticon은 여러 보안 도구를 동시에 실행하고 다양한 외부 API와 통신해야 하는 I/O 집약적인 애플리케이션입니다.
비동기 프로그래밍을 통해 네트워크 스캔, API 호출, 파일 I/O 등을 효율적으로 병렬 처리하여 전체적인 성능을 크게 향상시킬 수 있습니다.
특히 LangGraph의 스트리밍 실행과 MCP 도구들의 비동기 호출이 핵심적인 성능 요소입니다.
</context>

<references>
<reference as="dependency" href=".cursor/rules/main-project-rules.mdc" reason="기본 프로젝트 규칙">메인 프로젝트 규칙</reference>
<reference as="context" href=".cursor/rules/mcp-integration.mdc" reason="MCP 비동기 통합">MCP 비동기 처리</reference>
<reference as="context" href=".cursor/rules/error-handling.mdc" reason="비동기 에러 처리">에러 처리 규칙</reference>
</references>
</rule>
