---
description: MCP(Modular Command Protocol) 통합을 위한 개발 규칙과 패턴
globs: "src/tools/**/*.py"
alwaysApply: false
---

<rule>
<meta>
<title>MCP Integration Development Standards</title>
<description>MCP(Modular Command Protocol) 도구 통합과 관리를 위한 개발 표준</description>
<created-at utc-timestamp="1720684800">2025-07-08, 11:15 AM KST</created-at>
<last-updated-at utc-timestamp="1720684800">2025-07-08, 11:15 AM KST</last-updated-at>
<applies-to>
<file-matcher glob="src/tools/mcp/*.py">MCP 도구 파일</file-matcher>
<file-matcher glob="src/utils/mcp/*.py">MCP 유틸리티 파일</file-matcher>
<file-matcher glob="mcp_config.json">MCP 설정 파일</file-matcher>
</applies-to>
</meta>

<requirements>
<requirement priority="critical">
<description>MCP 도구는 langchain-mcp-adapters를 통해 표준화된 방식으로 로드하고 관리한다.</description>
<examples>
<example title="MCP 도구 로딩">
<correct-example title="표준화된 MCP 도구 로드" conditions="에이전트에 MCP 도구 추가" expected-result="안정적인 도구 통합" correctness-criteria="MultiServerMCPClient 사용"><![CDATA[
from langchain_mcp_adapters.client import MultiServerMCPClient
from typing import List, Dict, Any
import json

async def load_mcp_tools(agent_name: List[str]) -> List[Any]:
    """에이전트별 MCP 도구 로드"""
    all_tools = []
    
    try:
        # mcp_config.json에서 설정 로드
        with open("mcp_config.json", "r") as f:
            mcp_config = json.load(f)
        
        # 요청된 에이전트들의 도구만 로드
        for agent in agent_name:
            if agent not in mcp_config:
                print(f"Warning: No MCP config found for agent '{agent}'")
                continue
            
            agent_servers = mcp_config[agent]
            
            # 에이전트별 서버 설정에서 transport 기본값 설정
            for server_name, server_config in agent_servers.items():
                if "transport" not in server_config:
                    if "url" in server_config:
                        server_config["transport"] = "streamable_http"
                    else:
                        server_config["transport"] = "stdio"
            
            # MultiServerMCPClient로 도구 로드
            if agent_servers:
                client = MultiServerMCPClient(agent_servers)
                tools = await client.get_tools()
                all_tools.extend(tools)
                
                print(f"Loaded {len(tools)} MCP tools for agent '{agent}'")
    
    except FileNotFoundError:
        print("Warning: mcp_config.json not found")
    except Exception as e:
        print(f"Error loading MCP tools: {e}")
    
    return all_tools
]]></correct-example>
<incorrect-example title="하드코딩된 도구 로드" conditions="에이전트에 MCP 도구 추가" expected-result="안정적인 도구 통합" incorrectness-criteria="설정 파일 미사용"><![CDATA[
def load_mcp_tools_hardcoded() -> List[Any]:
    """하드코딩된 도구 로드 (잘못된 방식)"""
    tools = []
    
    # 하드코딩된 도구 설정
    nmap_tool = SomeNmapTool()
    metasploit_tool = SomeMetasploitTool()
    
    tools.extend([nmap_tool, metasploit_tool])
    
    return tools
]]></incorrect-example>
</example>
</examples>
</requirement>

<requirement priority="high">
<description>MCP 서버 설정은 mcp_config.json에서 관리하며, 각 에이전트별로 필요한 도구만 로드한다.</description>
<examples>
<example title="MCP 설정 구조">
<correct-example title="에이전트별 도구 분리" conditions="MCP 설정 파일 작성" expected-result="모듈화된 도구 관리" correctness-criteria="에이전트별 서버 그룹화"><![CDATA[
{
  "reconnaissance": {
    "reconnaissance_tools": {
      "command": "python",
      "args": ["./src/tools/mcp/Reconnaissance.py"],
      "transport": "stdio"
    },
    "network_scanner": {
      "url": "https://api.example.com/network-scanner/mcp",
      "transport": "streamable_http"
    }
  },
  "initial_access": {
    "exploit_tools": {
      "command": "python", 
      "args": ["./src/tools/mcp/Initial_Access.py"],
      "transport": "stdio"
    },
    "credential_tools": {
      "command": "python",
      "args": ["./src/tools/mcp/credential_tools.py"],
      "transport": "stdio"
    }
  },
  "planner": {
    "analysis_tools": {
      "url": "https://api.analysis.com/mcp?api_key=your-key",
      "transport": "streamable_http"
    }
  }
}
]]></correct-example>
<incorrect-example title="단일 설정으로 모든 도구" conditions="MCP 설정 파일 작성" expected-result="모듈화된 도구 관리" incorrectness-criteria="에이전트 구분 없는 설정"><![CDATA[
{
  "all_tools": {
    "reconnaissance": {
      "command": "python",
      "args": ["./src/tools/mcp/Reconnaissance.py"]
    },
    "initial_access": {
      "command": "python",
      "args": ["./src/tools/mcp/Initial_Access.py"]
    },
    "some_other_tool": {
      "url": "https://api.example.com/tool"
    }
  }
}
]]></incorrect-example>
</example>
</examples>
</requirement>

<requirement priority="high">
<description>MCP 도구 실행 시 적절한 에러 처리와 타임아웃을 설정한다.</description>
<examples>
<example title="안전한 MCP 도구 실행">
<correct-example title="타임아웃과 에러 처리" conditions="MCP 도구 호출" expected-result="안정적인 도구 실행" correctness-criteria="타임아웃과 예외 처리"><![CDATA[
import asyncio
from typing import Optional, Dict, Any

async def execute_mcp_tool_safely(
    tool_name: str, 
    tool_args: Dict[str, Any], 
    timeout: Optional[float] = 30.0
) -> Dict[str, Any]:
    """MCP 도구 안전 실행"""
    try:
        # 입력 검증
        if not tool_name or not isinstance(tool_args, dict):
            raise ValueError("Invalid tool name or arguments")
        
        # 타임아웃과 함께 도구 실행
        if timeout:
            result = await asyncio.wait_for(
                _execute_tool_internal(tool_name, tool_args),
                timeout=timeout
            )
        else:
            result = await _execute_tool_internal(tool_name, tool_args)
        
        return {
            "status": "success",
            "tool": tool_name,
            "result": result,
            "execution_time": time.time()
        }
    
    except asyncio.TimeoutError:
        return {
            "status": "timeout",
            "tool": tool_name,
            "error": f"Tool execution timed out after {timeout}s",
            "execution_time": time.time()
        }
    
    except Exception as e:
        return {
            "status": "error", 
            "tool": tool_name,
            "error": str(e),
            "execution_time": time.time()
        }

async def _execute_tool_internal(tool_name: str, tool_args: Dict[str, Any]) -> Any:
    """내부 도구 실행 로직"""
    # 실제 MCP 도구 호출
    tool = get_mcp_tool(tool_name)
    result = await tool.execute(**tool_args)
    return result
]]></correct-example>
<incorrect-example title="에러 처리 없는 도구 실행" conditions="MCP 도구 호출" expected-result="안정적인 도구 실행" incorrectness-criteria="에러 처리 및 타임아웃 누락"><![CDATA[
async def execute_mcp_tool_unsafe(tool_name: str, tool_args: Dict[str, Any]) -> Any:
    """에러 처리 없는 도구 실행 (위험)"""
    # 검증, 타임아웃, 에러 처리 없이 바로 실행
    tool = get_mcp_tool(tool_name)
    result = await tool.execute(**tool_args)
    return result
]]></incorrect-example>
</example>
</examples>
</requirement>

<requirement priority="medium">
<description>MCP 도구는 보안 및 권한 검증을 통과한 후에만 실행한다.</description>
<examples>
<example title="보안 검증">
<correct-example title="도구 실행 전 보안 검증" conditions="보안 도구 실행" expected-result="안전한 도구 실행" correctness-criteria="권한과 타겟 검증"><![CDATA[
from ipaddress import ip_address, ip_network
import re

class MCPSecurityValidator:
    """MCP 도구 보안 검증"""
    
    def __init__(self):
        # 허용된 IP 범위 (내부 네트워크만)
        self.allowed_networks = [
            ip_network("192.168.0.0/16"),
            ip_network("10.0.0.0/8"),
            ip_network("172.16.0.0/12")
        ]
        
        # 금지된 도구들
        self.forbidden_tools = [
            "format_disk",
            "delete_files", 
            "system_shutdown"
        ]
    
    def validate_target(self, target: str) -> bool:
        """타겟 IP/도메인 검증"""
        try:
            # IP 주소인 경우
            target_ip = ip_address(target)
            return any(target_ip in network for network in self.allowed_networks)
        except ValueError:
            # 도메인인 경우 패턴 검증
            domain_pattern = r'^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?(\.[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?)*$'
            return bool(re.match(domain_pattern, target))
    
    def validate_tool(self, tool_name: str) -> bool:
        """도구 사용 권한 검증"""
        return tool_name not in self.forbidden_tools
    
    def validate_execution(self, tool_name: str, target: str, user_id: str) -> Dict[str, Any]:
        """전체 실행 검증"""
        if not self.validate_tool(tool_name):
            return {"allowed": False, "reason": f"Tool '{tool_name}' is forbidden"}
        
        if not self.validate_target(target):
            return {"allowed": False, "reason": f"Target '{target}' is not allowed"}
        
        # 추가 사용자 권한 검증 로직
        if not self._check_user_permissions(user_id, tool_name):
            return {"allowed": False, "reason": "Insufficient user permissions"}
        
        return {"allowed": True, "reason": "Validation passed"}

async def execute_secure_mcp_tool(
    tool_name: str, 
    target: str, 
    user_id: str, 
    **kwargs
) -> Dict[str, Any]:
    """보안 검증을 포함한 MCP 도구 실행"""
    validator = MCPSecurityValidator()
    
    # 보안 검증
    validation = validator.validate_execution(tool_name, target, user_id)
    if not validation["allowed"]:
        return {
            "status": "blocked",
            "reason": validation["reason"],
            "tool": tool_name,
            "target": target
        }
    
    # 검증 통과 후 도구 실행
    return await execute_mcp_tool_safely(tool_name, {"target": target, **kwargs})
]]></correct-example>
<incorrect-example title="검증 없는 도구 실행" conditions="보안 도구 실행" expected-result="안전한 도구 실행" incorrectness-criteria="보안 검증 누락"><![CDATA[
async def execute_mcp_tool_insecure(tool_name: str, target: str, **kwargs) -> Any:
    """보안 검증 없는 도구 실행 (위험)"""
    # 어떤 타겟이든, 어떤 도구든 검증 없이 실행
    tool = get_mcp_tool(tool_name)
    result = await tool.execute(target=target, **kwargs)
    return result
]]></incorrect-example>
</example>
</examples>
</requirement>

<non-negotiable priority="critical">
<description>MCP 도구 개발 시 표준 MCP 프로토콜을 준수하고 적절한 도구 스키마를 정의한다.</description>
<examples>
<example title="MCP 도구 표준 구현">
<correct-example title="표준 MCP 도구 구현" conditions="새로운 MCP 도구 개발" expected-result="MCP 프로토콜 준수" correctness-criteria="MCP Server 클래스와 스키마 사용"><![CDATA[
#!/usr/bin/env python3
"""
Network Reconnaissance MCP Server
표준 MCP 프로토콜을 준수하는 네트워크 정찰 도구
"""

import asyncio
import json
from typing import Any, Dict, List
from mcp.server import MCPServer
from mcp.types import Tool, TextContent
from pydantic import BaseModel, Field

class NetworkScanArgs(BaseModel):
    """네트워크 스캔 인수 스키마"""
    target: str = Field(description="스캔할 타겟 IP 또는 도메인")
    scan_type: str = Field(
        default="quick",
        description="스캔 유형: quick, full, stealth"
    )
    ports: str = Field(
        default="1-1000", 
        description="스캔할 포트 범위 (예: 1-1000, 80,443,8080)"
    )

class PortScanArgs(BaseModel):
    """포트 스캔 인수 스키마"""
    target: str = Field(description="스캔할 타겟 IP")
    port: int = Field(description="스캔할 포트 번호")

# MCP 서버 초기화
server = MCPServer("network-reconnaissance")

@server.list_tools()
async def list_tools() -> List[Tool]:
    """사용 가능한 도구 목록 반환"""
    return [
        Tool(
            name="network_scan",
            description="네트워크 대상에 대한 포트 스캔 수행",
            inputSchema=NetworkScanArgs.model_json_schema()
        ),
        Tool(
            name="port_scan", 
            description="특정 포트의 상태 확인",
            inputSchema=PortScanArgs.model_json_schema()
        ),
        Tool(
            name="service_detection",
            description="열린 포트에서 실행 중인 서비스 탐지",
            inputSchema=NetworkScanArgs.model_json_schema()
        )
    ]

@server.call_tool()
async def call_tool(name: str, arguments: Dict[str, Any]) -> List[TextContent]:
    """도구 호출 처리"""
    try:
        if name == "network_scan":
            args = NetworkScanArgs(**arguments)
            result = await perform_network_scan(args.target, args.scan_type, args.ports)
            
        elif name == "port_scan":
            args = PortScanArgs(**arguments)
            result = await perform_port_scan(args.target, args.port)
            
        elif name == "service_detection":
            args = NetworkScanArgs(**arguments)
            result = await perform_service_detection(args.target, args.ports)
            
        else:
            raise ValueError(f"Unknown tool: {name}")
        
        return [TextContent(
            type="text",
            text=json.dumps(result, indent=2)
        )]
    
    except Exception as e:
        return [TextContent(
            type="text", 
            text=f"Error executing {name}: {str(e)}"
        )]

async def perform_network_scan(target: str, scan_type: str, ports: str) -> Dict[str, Any]:
    """실제 네트워크 스캔 수행"""
    # 스캔 로직 구현
    return {
        "target": target,
        "scan_type": scan_type,
        "open_ports": [22, 80, 443],
        "closed_ports": [21, 23, 25],
        "scan_time": "2025-07-08 11:20:00"
    }

if __name__ == "__main__":
    asyncio.run(server.run())
]]></correct-example>
<incorrect-example title="비표준 도구 구현" conditions="새로운 MCP 도구 개발" expected-result="MCP 프로토콜 준수" incorrectness-criteria="MCP 프로토콜 미준수"><![CDATA[
# 비표준 도구 구현 (잘못된 방식)
class CustomTool:
    def __init__(self, name):
        self.name = name
    
    def execute(self, **kwargs):
        # MCP 프로토콜을 따르지 않는 사용자 정의 인터페이스
        return {"result": "some_data"}

def create_tools():
    return [
        CustomTool("scan_tool"),
        CustomTool("exploit_tool")
    ]
]]></incorrect-example>
</example>
</examples>
</non-negotiable>
</requirements>

<context description="MCP 통합 컨텍스트">
Decepticon은 MCP(Modular Command Protocol)를 통해 다양한 보안 도구들을 모듈화하여 통합합니다.
각 에이전트는 필요한 MCP 도구만 로드하여 특화된 기능을 수행하며, 
langchain-mcp-adapters를 통해 LangChain 생태계와 자연스럽게 통합됩니다.
보안 도구의 특성상 적절한 권한 검증과 타겟 검증이 필수적입니다.
</context>

<references>
<reference as="dependency" href=".cursor/rules/main-project-rules.mdc" reason="기본 프로젝트 규칙">메인 프로젝트 규칙</reference>
<reference as="context" href=".cursor/rules/security-pentesting.mdc" reason="보안 도구 개발">보안 및 펜테스팅 규칙</reference>
<reference as="context" href=".cursor/rules/async-patterns.mdc" reason="비동기 MCP 처리">비동기 프로그래밍 패턴</reference>
</references>
</rule>
