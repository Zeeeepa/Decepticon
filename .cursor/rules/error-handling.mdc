---
description: ê°•ê±´í•œ ì—ëŸ¬ ì²˜ë¦¬ì™€ ì˜ˆì™¸ ê´€ë¦¬ë¥¼ ìœ„í•œ í¬ê´„ì  ê°€ì´ë“œë¼ì¸
globs: "**/*.py"
alwaysApply: false
---

<rule>
<meta>
<title>Error Handling and Exception Management</title>
<description>ì•ˆì •ì ì¸ ì‹œìŠ¤í…œì„ ìœ„í•œ ì—ëŸ¬ ì²˜ë¦¬, ì˜ˆì™¸ ê´€ë¦¬, ë³µêµ¬ ì „ëµì˜ ëª¨ë²” ì‚¬ë¡€</description>
<created-at utc-timestamp="1720684800">2025-07-08, 11:35 AM KST</created-at>
<last-updated-at utc-timestamp="1720684800">2025-07-08, 11:35 AM KST</last-updated-at>
<applies-to>
<file-matcher glob="**/*.py">ëª¨ë“  Python íŒŒì¼</file-matcher>
<action-matcher action="error-handling">ì—ëŸ¬ ì²˜ë¦¬ êµ¬í˜„ ì‹œ</action-matcher>
</applies-to>
</meta>

<requirements>
<requirement priority="critical">
<description>ëª¨ë“  ì™¸ë¶€ ì˜ì¡´ì„± í˜¸ì¶œì€ ì ì ˆí•œ ì˜ˆì™¸ ì²˜ë¦¬ì™€ fallback ë©”ì»¤ë‹ˆì¦˜ì„ í¬í•¨í•œë‹¤.</description>
<examples>
<example title="ì™¸ë¶€ API í˜¸ì¶œ ì—ëŸ¬ ì²˜ë¦¬">
<correct-example title="ë³µì›ë ¥ ìˆëŠ” API í˜¸ì¶œ" conditions="ì™¸ë¶€ API í˜¸ì¶œ" expected-result="ì•ˆì •ì ì¸ ì‹œìŠ¤í…œ ë™ì‘" correctness-criteria="ì˜ˆì™¸ ì²˜ë¦¬ì™€ fallback í¬í•¨"><![CDATA[
import aiohttp
import asyncio
from typing import Optional, Dict, Any, Union
from dataclasses import dataclass
from enum import Enum
import logging

class ErrorSeverity(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

@dataclass
class ErrorContext:
    """ì—ëŸ¬ ì»¨í…ìŠ¤íŠ¸ ì •ë³´"""
    operation: str
    component: str
    user_id: Optional[str] = None
    session_id: Optional[str] = None
    request_id: Optional[str] = None

class ResilientAPIClient:
    """ë³µì›ë ¥ ìˆëŠ” API í´ë¼ì´ì–¸íŠ¸"""
    
    def __init__(self, base_url: str, max_retries: int = 3, timeout: float = 30.0):
        self.base_url = base_url
        self.max_retries = max_retries
        self.timeout = timeout
        self.logger = logging.getLogger(__name__)
    
    async def make_request(
        self,
        endpoint: str,
        method: str = "GET",
        data: Optional[Dict[str, Any]] = None,
        context: Optional[ErrorContext] = None
    ) -> Dict[str, Any]:
        """ë³µì›ë ¥ ìˆëŠ” API ìš”ì²­"""
        
        last_exception = None
        
        for attempt in range(self.max_retries + 1):
            try:
                async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=self.timeout)) as session:
                    url = f"{self.base_url}/{endpoint.lstrip('/')}"
                    
                    async with session.request(method, url, json=data) as response:
                        if response.status == 200:
                            result = await response.json()
                            
                            # ì„±ê³µ ì‹œ ì´ì „ ì‹¤íŒ¨ ê¸°ë¡ ì •ë¦¬
                            if attempt > 0:
                                self.logger.info(f"Request succeeded on attempt {attempt + 1}")
                            
                            return {
                                "status": "success",
                                "data": result,
                                "attempts": attempt + 1
                            }
                        
                        elif response.status in [429, 503]:  # Rate limit, Service unavailable
                            # ì¬ì‹œë„ ê°€ëŠ¥í•œ ì—ëŸ¬
                            wait_time = min(2 ** attempt, 60)  # Exponential backoff with cap
                            self.logger.warning(f"Retryable error {response.status}, waiting {wait_time}s")
                            await asyncio.sleep(wait_time)
                            continue
                        
                        elif response.status in [401, 403]:  # Authentication errors
                            # ì¬ì‹œë„ ë¶ˆê°€ëŠ¥í•œ ì—ëŸ¬
                            error_data = await response.text()
                            return await self._handle_auth_error(response.status, error_data, context)
                        
                        else:
                            # ê¸°íƒ€ HTTP ì—ëŸ¬
                            error_data = await response.text()
                            raise aiohttp.ClientResponseError(
                                request_info=response.request_info,
                                history=response.history,
                                status=response.status,
                                message=error_data
                            )
            
            except asyncio.TimeoutError as e:
                last_exception = e
                self.logger.warning(f"Request timeout on attempt {attempt + 1}")
                if attempt < self.max_retries:
                    await asyncio.sleep(2 ** attempt)  # Exponential backoff
                
            except aiohttp.ClientError as e:
                last_exception = e
                self.logger.warning(f"Client error on attempt {attempt + 1}: {e}")
                if attempt < self.max_retries:
                    await asyncio.sleep(2 ** attempt)
            
            except Exception as e:
                last_exception = e
                self.logger.error(f"Unexpected error on attempt {attempt + 1}: {e}")
                break  # ì˜ˆìƒì¹˜ ëª»í•œ ì—ëŸ¬ëŠ” ì¬ì‹œë„í•˜ì§€ ì•ŠìŒ
        
        # ëª¨ë“  ì¬ì‹œë„ ì‹¤íŒ¨
        return await self._handle_final_failure(last_exception, endpoint, context)
    
    async def _handle_auth_error(
        self, 
        status_code: int, 
        error_data: str, 
        context: Optional[ErrorContext]
    ) -> Dict[str, Any]:
        """ì¸ì¦ ì—ëŸ¬ ì²˜ë¦¬"""
        self.logger.error(f"Authentication error {status_code}: {error_data}")
        
        # ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ì—ëŸ¬ ë³´ê³ 
        if context:
            await self._report_error(
                ErrorSeverity.HIGH,
                f"Authentication failed for {context.operation}",
                context
            )
        
        return {
            "status": "auth_error",
            "error_code": status_code,
            "message": "Authentication or authorization failed",
            "recoverable": False,
            "action_required": "Check API credentials"
        }
    
    async def _handle_final_failure(
        self,
        exception: Exception,
        endpoint: str,
        context: Optional[ErrorContext]
    ) -> Dict[str, Any]:
        """ìµœì¢… ì‹¤íŒ¨ ì²˜ë¦¬"""
        error_message = f"API call to {endpoint} failed after {self.max_retries + 1} attempts: {exception}"
        self.logger.error(error_message)
        
        # ì‹¬ê°í•œ ì—ëŸ¬ ë³´ê³ 
        if context:
            await self._report_error(
                ErrorSeverity.CRITICAL,
                error_message,
                context
            )
        
        # Fallback ë°ì´í„° ì œê³µ ì‹œë„
        fallback_data = await self._get_fallback_data(endpoint)
        
        return {
            "status": "failed",
            "error": str(exception),
            "endpoint": endpoint,
            "attempts": self.max_retries + 1,
            "fallback_data": fallback_data,
            "recovery_suggestions": [
                "Check network connectivity",
                "Verify API endpoint availability", 
                "Review API rate limits",
                "Check authentication credentials"
            ]
        }
    
    async def _get_fallback_data(self, endpoint: str) -> Optional[Dict[str, Any]]:
        """Fallback ë°ì´í„° ì œê³µ"""
        # ìºì‹œëœ ë°ì´í„°ë‚˜ ê¸°ë³¸ê°’ ë°˜í™˜
        fallback_map = {
            "status": {"service": "degraded", "timestamp": "unknown"},
            "config": {"default": True, "version": "fallback"},
            "data": {"cached": True, "stale": True}
        }
        
        for key in fallback_map:
            if key in endpoint:
                return fallback_map[key]
        
        return None
    
    async def _report_error(
        self,
        severity: ErrorSeverity,
        message: str,
        context: ErrorContext
    ) -> None:
        """ì—ëŸ¬ ë³´ê³  ë° ì•Œë¦¼"""
        error_report = {
            "severity": severity.value,
            "message": message,
            "timestamp": datetime.now().isoformat(),
            "context": {
                "operation": context.operation,
                "component": context.component,
                "user_id": context.user_id,
                "session_id": context.session_id,
                "request_id": context.request_id
            }
        }
        
        # ì‹¬ê°ë„ì— ë”°ë¥¸ ì•Œë¦¼ ì²˜ë¦¬
        if severity == ErrorSeverity.CRITICAL:
            # ì¦‰ì‹œ ì•Œë¦¼ ë°œì†¡
            await self._send_critical_alert(error_report)
        
        # ì—ëŸ¬ ë¡œê·¸ ì €ì¥
        await self._save_error_log(error_report)

# ì‚¬ìš© ì˜ˆì‹œ
async def fetch_vulnerability_data_safely(cve_id: str, user_id: str) -> Dict[str, Any]:
    """ì•ˆì „í•œ ì·¨ì•½ì  ë°ì´í„° ì¡°íšŒ"""
    client = ResilientAPIClient("https://services.nvd.nist.gov/rest/json/cves/2.0")
    
    context = ErrorContext(
        operation="fetch_vulnerability_data",
        component="cve_api_client",
        user_id=user_id,
        request_id=str(uuid.uuid4())
    )
    
    result = await client.make_request(
        endpoint=f"?cveId={cve_id}",
        context=context
    )
    
    if result["status"] == "success":
        return result["data"]
    elif result.get("fallback_data"):
        return {
            "cve_id": cve_id,
            "status": "fallback",
            "data": result["fallback_data"],
            "warning": "Using fallback data due to API unavailability"
        }
    else:
        return {
            "cve_id": cve_id,
            "status": "unavailable",
            "error": result["error"],
            "suggestions": result["recovery_suggestions"]
        }
]]></correct-example>
<incorrect-example title="ê¸°ë³¸ì ì¸ try-catch" conditions="ì™¸ë¶€ API í˜¸ì¶œ" expected-result="ì•ˆì •ì ì¸ ì‹œìŠ¤í…œ ë™ì‘" incorrectness-criteria="ì¬ì‹œë„ ë¡œì§ê³¼ fallback ëˆ„ë½"><![CDATA[
async def fetch_vulnerability_data_basic(cve_id: str) -> Dict[str, Any]:
    """ê¸°ë³¸ì ì¸ ì—ëŸ¬ ì²˜ë¦¬ (ë¶ˆì™„ì „)"""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(f"https://api.example.com/cve/{cve_id}") as response:
                data = await response.json()
                return data
    except Exception as e:
        # ë‹¨ìˆœí•œ ì—ëŸ¬ ì²˜ë¦¬ - ì¬ì‹œë„, fallback, ìƒì„¸ ì»¨í…ìŠ¤íŠ¸ ì—†ìŒ
        return {"error": str(e)}
]]></incorrect-example>
</example>
</examples>
</requirement>

<requirement priority="high">
<description>ì—ì´ì „íŠ¸ ì‹¤í–‰ ì¤‘ ë°œìƒí•˜ëŠ” ì—ëŸ¬ëŠ” ì ì ˆíˆ ë¡œê¹…í•˜ê³  ì‚¬ìš©ìì—ê²Œ ìœ ìš©í•œ í”¼ë“œë°±ì„ ì œê³µí•œë‹¤.</description>
<examples>
<example title="ì—ì´ì „íŠ¸ ì—ëŸ¬ ì²˜ë¦¬">
<correct-example title="í¬ê´„ì ì¸ ì—ì´ì „íŠ¸ ì—ëŸ¬ ê´€ë¦¬" conditions="ì—ì´ì „íŠ¸ ì‹¤í–‰ ì—ëŸ¬" expected-result="ìœ ìš©í•œ ì‚¬ìš©ì í”¼ë“œë°±" correctness-criteria="êµ¬ì¡°í™”ëœ ì—ëŸ¬ ì •ë³´ì™€ ë³µêµ¬ ì œì•ˆ"><![CDATA[
from typing import Dict, Any, Optional, List
from dataclasses import dataclass, field
from datetime import datetime
import traceback
import sys

@dataclass
class AgentError:
    """ì—ì´ì „íŠ¸ ì—ëŸ¬ ì •ë³´"""
    agent_name: str
    operation: str
    error_type: str
    error_message: str
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())
    stack_trace: Optional[str] = None
    user_message: str = ""
    recovery_suggestions: List[str] = field(default_factory=list)
    context: Dict[str, Any] = field(default_factory=dict)

class AgentErrorHandler:
    """ì—ì´ì „íŠ¸ ì—ëŸ¬ í•¸ë“¤ëŸ¬"""
    
    def __init__(self):
        self.logger = logging.getLogger("agent_errors")
        self.error_patterns = {
            "llm_api_error": {
                "user_message": "AI ëª¨ë¸ ì„œë¹„ìŠ¤ì— ì¼ì‹œì ì¸ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
                "suggestions": [
                    "ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”",
                    "ë‹¤ë¥¸ AI ëª¨ë¸ë¡œ ë³€ê²½í•´ë³´ì„¸ìš”",
                    "ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”"
                ]
            },
            "mcp_tool_error": {
                "user_message": "ë³´ì•ˆ ë„êµ¬ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
                "suggestions": [
                    "íƒ€ê²Ÿ ì£¼ì†Œê°€ ì˜¬ë°”ë¥¸ì§€ í™•ì¸í•´ì£¼ì„¸ìš”",
                    "ë„êµ¬ ì„¤ì •ì„ ì ê²€í•´ì£¼ì„¸ìš”",
                    "ë„¤íŠ¸ì›Œí¬ ì ‘ê·¼ ê¶Œí•œì„ í™•ì¸í•´ì£¼ì„¸ìš”"
                ]
            },
            "memory_error": {
                "user_message": "ë©”ëª¨ë¦¬ ì‹œìŠ¤í…œì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
                "suggestions": [
                    "ì´ì „ ëŒ€í™” ë‚´ìš©ì„ ë‹¤ì‹œ ìš”ì•½í•´ì£¼ì„¸ìš”",
                    "ìƒˆ ì„¸ì…˜ì„ ì‹œì‘í•´ì£¼ì„¸ìš”",
                    "ë©”ëª¨ë¦¬ ì €ì¥ì†Œ ìƒíƒœë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”"
                ]
            },
            "handoff_error": {
                "user_message": "ì—ì´ì „íŠ¸ ê°„ ì‘ì—… ì „ë‹¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.",
                "suggestions": [
                    "ë‹¤ë¥¸ ì—ì´ì „íŠ¸ë¡œ ì§ì ‘ ìš”ì²­í•´ì£¼ì„¸ìš”",
                    "ì‘ì—…ì„ ë” ì‘ì€ ë‹¨ìœ„ë¡œ ë‚˜ëˆ„ì–´ì£¼ì„¸ìš”",
                    "ì‹œìŠ¤í…œ ìƒíƒœë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”"
                ]
            }
        }
    
    async def handle_agent_error(
        self,
        agent_name: str,
        operation: str,
        exception: Exception,
        context: Dict[str, Any] = None
    ) -> AgentError:
        """ì—ì´ì „íŠ¸ ì—ëŸ¬ ì²˜ë¦¬ ë° ë¶„ì„"""
        
        # ì—ëŸ¬ íƒ€ì… ë¶„ë¥˜
        error_type = self._classify_error(exception)
        
        # ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ìº¡ì²˜
        stack_trace = traceback.format_exc()
        
        # ì—ëŸ¬ íŒ¨í„´ ë§¤ì¹­í•˜ì—¬ ì‚¬ìš©ì ë©”ì‹œì§€ ìƒì„±
        pattern_info = self.error_patterns.get(error_type, {})
        user_message = pattern_info.get("user_message", "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
        suggestions = pattern_info.get("suggestions", ["ì‹œìŠ¤í…œ ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•´ì£¼ì„¸ìš”"])
        
        # ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ì¶”ê°€ ì •ë³´
        if context:
            user_message = self._enhance_user_message(user_message, context)
            suggestions = self._enhance_suggestions(suggestions, context, error_type)
        
        # ì—ì´ì „íŠ¸ ì—ëŸ¬ ê°ì²´ ìƒì„±
        agent_error = AgentError(
            agent_name=agent_name,
            operation=operation,
            error_type=error_type,
            error_message=str(exception),
            stack_trace=stack_trace,
            user_message=user_message,
            recovery_suggestions=suggestions,
            context=context or {}
        )
        
        # ì—ëŸ¬ ë¡œê¹…
        await self._log_agent_error(agent_error)
        
        # ì‹¬ê°í•œ ì—ëŸ¬ì¸ ê²½ìš° ì•Œë¦¼
        if self._is_critical_error(error_type, exception):
            await self._send_error_notification(agent_error)
        
        return agent_error
    
    def _classify_error(self, exception: Exception) -> str:
        """ì—ëŸ¬ íƒ€ì… ë¶„ë¥˜"""
        error_class = type(exception).__name__
        error_message = str(exception).lower()
        
        # API ê´€ë ¨ ì—ëŸ¬
        if any(keyword in error_message for keyword in ["api", "openai", "anthropic", "rate limit"]):
            return "llm_api_error"
        
        # MCP ë„êµ¬ ì—ëŸ¬
        if any(keyword in error_message for keyword in ["mcp", "tool", "nmap", "scan"]):
            return "mcp_tool_error"
        
        # ë©”ëª¨ë¦¬ ê´€ë ¨ ì—ëŸ¬
        if any(keyword in error_message for keyword in ["memory", "store", "namespace"]):
            return "memory_error"
        
        # í•¸ë“œì˜¤í”„ ì—ëŸ¬
        if any(keyword in error_message for keyword in ["handoff", "agent", "transfer"]):
            return "handoff_error"
        
        # ê¸°ë³¸ ë¶„ë¥˜
        return error_class.lower()
    
    def _enhance_user_message(self, base_message: str, context: Dict[str, Any]) -> str:
        """ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ì‚¬ìš©ì ë©”ì‹œì§€ í–¥ìƒ"""
        if "target" in context:
            return f"{base_message} (ëŒ€ìƒ: {context['target']})"
        elif "tool_name" in context:
            return f"{base_message} (ë„êµ¬: {context['tool_name']})"
        else:
            return base_message
    
    def _enhance_suggestions(
        self, 
        base_suggestions: List[str], 
        context: Dict[str, Any], 
        error_type: str
    ) -> List[str]:
        """ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ë³µêµ¬ ì œì•ˆ í–¥ìƒ"""
        enhanced = base_suggestions.copy()
        
        # íƒ€ê²Ÿ ê´€ë ¨ ì œì•ˆ
        if "target" in context and error_type == "mcp_tool_error":
            target = context["target"]
            enhanced.append(f"íƒ€ê²Ÿ {target}ì´ ì ‘ê·¼ ê°€ëŠ¥í•œì§€ í™•ì¸í•´ì£¼ì„¸ìš”")
            enhanced.append(f"íƒ€ê²Ÿ {target}ì— ëŒ€í•œ ê¶Œí•œì´ ìˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”")
        
        # LLM ê´€ë ¨ ì œì•ˆ
        if error_type == "llm_api_error":
            enhanced.append("AI ëª¨ë¸ ì„¤ì •ì—ì„œ ë‹¤ë¥¸ ê³µê¸‰ìë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”")
            enhanced.append("API í‚¤ê°€ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •ë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”")
        
        return enhanced
    
    def _is_critical_error(self, error_type: str, exception: Exception) -> bool:
        """ì‹¬ê°í•œ ì—ëŸ¬ ì—¬ë¶€ íŒë‹¨"""
        critical_patterns = [
            "system", "critical", "fatal", "corruption",
            "security", "authentication", "authorization"
        ]
        
        error_message = str(exception).lower()
        return any(pattern in error_message for pattern in critical_patterns)
    
    async def _log_agent_error(self, agent_error: AgentError) -> None:
        """ì—ì´ì „íŠ¸ ì—ëŸ¬ ë¡œê¹…"""
        log_data = {
            "timestamp": agent_error.timestamp,
            "agent": agent_error.agent_name,
            "operation": agent_error.operation,
            "error_type": agent_error.error_type,
            "error_message": agent_error.error_message,
            "context": agent_error.context
        }
        
        self.logger.error(f"Agent Error: {log_data}")
        
        # ë””ë²„ê·¸ ë ˆë²¨ì—ì„œ ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤ ë¡œê¹…
        if agent_error.stack_trace:
            self.logger.debug(f"Stack Trace: {agent_error.stack_trace}")
    
    async def _send_error_notification(self, agent_error: AgentError) -> None:
        """ì‹¬ê°í•œ ì—ëŸ¬ ì•Œë¦¼ ë°œì†¡"""
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì´ë©”ì¼, Slack, ì›¹í›… ë“±ìœ¼ë¡œ ì•Œë¦¼
        print(f"ğŸš¨ CRITICAL ERROR ALERT ğŸš¨")
        print(f"Agent: {agent_error.agent_name}")
        print(f"Error: {agent_error.error_message}")
        print(f"Time: {agent_error.timestamp}")

# ì—ì´ì „íŠ¸ ë˜í¼ í•¨ìˆ˜
async def execute_agent_with_error_handling(
    agent_func: callable,
    agent_name: str,
    operation: str,
    *args,
    **kwargs
) -> Dict[str, Any]:
    """ì—ëŸ¬ ì²˜ë¦¬ê°€ í¬í•¨ëœ ì—ì´ì „íŠ¸ ì‹¤í–‰"""
    error_handler = AgentErrorHandler()
    
    try:
        result = await agent_func(*args, **kwargs)
        return {
            "status": "success",
            "result": result,
            "agent": agent_name
        }
    
    except Exception as e:
        agent_error = await error_handler.handle_agent_error(
            agent_name=agent_name,
            operation=operation,
            exception=e,
            context=kwargs
        )
        
        return {
            "status": "error",
            "agent": agent_name,
            "error_info": {
                "type": agent_error.error_type,
                "message": agent_error.user_message,
                "suggestions": agent_error.recovery_suggestions,
                "technical_details": agent_error.error_message
            }
        }
]]></correct-example>
<incorrect-example title="ê¸°ë³¸ ì—ëŸ¬ ì²˜ë¦¬" conditions="ì—ì´ì „íŠ¸ ì‹¤í–‰ ì—ëŸ¬" expected-result="ìœ ìš©í•œ ì‚¬ìš©ì í”¼ë“œë°±" incorrectness-criteria="ì‚¬ìš©ì ì¹œí™”ì  ë©”ì‹œì§€ì™€ ë³µêµ¬ ì œì•ˆ ëˆ„ë½"><![CDATA[
async def execute_agent_basic(agent_func: callable) -> Any:
    """ê¸°ë³¸ì ì¸ ì—ëŸ¬ ì²˜ë¦¬"""
    try:
        result = await agent_func()
        return result
    except Exception as e:
        # ë‹¨ìˆœí•œ ì—ëŸ¬ ë°˜í™˜ - ì‚¬ìš©ì ì¹œí™”ì  ë©”ì‹œì§€ë‚˜ ë³µêµ¬ ì œì•ˆ ì—†ìŒ
        return {"error": str(e)}
]]></incorrect-example>
</example>
</examples>
</requirement>

<requirement priority="high">
<description>íŒŒì¼ I/Oì™€ ì„¤ì • ë¡œë”©ì—ì„œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ì—ëŸ¬ë¥¼ ì˜ˆì¸¡í•˜ê³  ëŒ€ì‘í•œë‹¤.</description>
<examples>
<example title="ì•ˆì „í•œ íŒŒì¼ ë° ì„¤ì • ì²˜ë¦¬">
<correct-example title="ê°•ê±´í•œ íŒŒì¼ I/O" conditions="íŒŒì¼ ì½ê¸°/ì“°ê¸° ì‘ì—…" expected-result="ì•ˆì •ì ì¸ íŒŒì¼ ì²˜ë¦¬" correctness-criteria="íŒŒì¼ ì¡´ì¬, ê¶Œí•œ, í˜•ì‹ ê²€ì¦"><![CDATA[
import json
import yaml
import aiofiles
from pathlib import Path
from typing import Dict, Any, Optional, Union
import asyncio
import logging

class ConfigurationManager:
    """ì„¤ì • íŒŒì¼ ê´€ë¦¬ì"""
    
    def __init__(self, base_path: Union[str, Path] = "."):
        self.base_path = Path(base_path)
        self.logger = logging.getLogger(__name__)
        self.default_configs = {
            "mcp_config.json": {
                "reconnaissance": {},
                "initial_access": {},
                "planner": {}
            },
            ".env": {
                "OPENAI_API_KEY": "",
                "ANTHROPIC_API_KEY": "",
                "LANGSMITH_API_KEY": ""
            }
        }
    
    async def load_config_safely(
        self, 
        config_file: str,
        required_fields: Optional[List[str]] = None
    ) -> Dict[str, Any]:
        """ì•ˆì „í•œ ì„¤ì • íŒŒì¼ ë¡œë”©"""
        config_path = self.base_path / config_file
        
        try:
            # 1. íŒŒì¼ ì¡´ì¬ í™•ì¸
            if not config_path.exists():
                self.logger.warning(f"Config file {config_file} not found, creating default")
                return await self._create_default_config(config_file)
            
            # 2. íŒŒì¼ ì½ê¸° ê¶Œí•œ í™•ì¸
            if not config_path.is_file() or not os.access(config_path, os.R_OK):
                raise PermissionError(f"Cannot read config file {config_file}")
            
            # 3. íŒŒì¼ í¬ê¸° ê²€ì¦ (ë¹„ì •ìƒì ìœ¼ë¡œ í° íŒŒì¼ ë°©ì§€)
            file_size = config_path.stat().st_size
            if file_size > 10 * 1024 * 1024:  # 10MB ì œí•œ
                raise ValueError(f"Config file {config_file} is too large ({file_size} bytes)")
            
            # 4. íŒŒì¼ í˜•ì‹ì— ë”°ë¥¸ íŒŒì‹±
            config_data = await self._parse_config_file(config_path)
            
            # 5. í•„ìˆ˜ í•„ë“œ ê²€ì¦
            if required_fields:
                missing_fields = self._validate_required_fields(config_data, required_fields)
                if missing_fields:
                    # ëˆ„ë½ëœ í•„ë“œì— ê¸°ë³¸ê°’ ì¶”ê°€
                    config_data = await self._add_missing_fields(config_data, missing_fields, config_file)
            
            # 6. ì„¤ì • ê²€ì¦
            validated_config = self._validate_config_values(config_data, config_file)
            
            self.logger.info(f"Successfully loaded config from {config_file}")
            return validated_config
        
        except json.JSONDecodeError as e:
            self.logger.error(f"Invalid JSON in {config_file}: {e}")
            return await self._handle_corrupted_config(config_file, "json_error")
        
        except yaml.YAMLError as e:
            self.logger.error(f"Invalid YAML in {config_file}: {e}")
            return await self._handle_corrupted_config(config_file, "yaml_error")
        
        except PermissionError as e:
            self.logger.error(f"Permission denied for {config_file}: {e}")
            return await self._handle_permission_error(config_file)
        
        except Exception as e:
            self.logger.error(f"Unexpected error loading {config_file}: {e}")
            return await self._handle_general_error(config_file, e)
    
    async def _parse_config_file(self, config_path: Path) -> Dict[str, Any]:
        """íŒŒì¼ í˜•ì‹ì— ë”°ë¥¸ íŒŒì‹±"""
        file_extension = config_path.suffix.lower()
        
        try:
            async with aiofiles.open(config_path, 'r', encoding='utf-8') as file:
                content = await file.read()
                
                # ë¹ˆ íŒŒì¼ ì²´í¬
                if not content.strip():
                    self.logger.warning(f"Config file {config_path.name} is empty")
                    return {}
                
                if file_extension == '.json':
                    return json.loads(content)
                elif file_extension in ['.yml', '.yaml']:
                    return yaml.safe_load(content) or {}
                elif file_extension == '.env':
                    return self._parse_env_file(content)
                else:
                    # ê¸°ë³¸ì ìœ¼ë¡œ JSONìœ¼ë¡œ ì‹œë„
                    try:
                        return json.loads(content)
                    except json.JSONDecodeError:
                        # JSONì´ ì•„ë‹ˆë©´ YAMLë¡œ ì‹œë„
                        return yaml.safe_load(content) or {}
        
        except UnicodeDecodeError as e:
            raise ValueError(f"File encoding error in {config_path.name}: {e}")
    
    def _parse_env_file(self, content: str) -> Dict[str, str]:
        """í™˜ê²½ ë³€ìˆ˜ íŒŒì¼ íŒŒì‹±"""
        env_vars = {}
        for line in content.split('\n'):
            line = line.strip()
            if line and not line.startswith('#') and '=' in line:
                key, value = line.split('=', 1)
                # ë”°ì˜´í‘œ ì œê±°
                value = value.strip().strip('"').strip("'")
                env_vars[key.strip()] = value
        return env_vars
    
    def _validate_required_fields(
        self, 
        config: Dict[str, Any], 
        required_fields: List[str]
    ) -> List[str]:
        """í•„ìˆ˜ í•„ë“œ ê²€ì¦"""
        missing_fields = []
        for field in required_fields:
            if '.' in field:
                # ì¤‘ì²©ëœ í•„ë“œ ê²€ì¦ (ì˜ˆ: "database.host")
                parts = field.split('.')
                current = config
                for part in parts:
                    if not isinstance(current, dict) or part not in current:
                        missing_fields.append(field)
                        break
                    current = current[part]
            else:
                if field not in config:
                    missing_fields.append(field)
        
        return missing_fields
    
    async def _add_missing_fields(
        self, 
        config: Dict[str, Any], 
        missing_fields: List[str],
        config_file: str
    ) -> Dict[str, Any]:
        """ëˆ„ë½ëœ í•„ë“œì— ê¸°ë³¸ê°’ ì¶”ê°€"""
        updated_config = config.copy()
        default_config = self.default_configs.get(config_file, {})
        
        for field in missing_fields:
            if field in default_config:
                updated_config[field] = default_config[field]
                self.logger.info(f"Added default value for missing field '{field}' in {config_file}")
        
        # ì—…ë°ì´íŠ¸ëœ ì„¤ì •ì„ íŒŒì¼ì— ì €ì¥
        try:
            await self.save_config_safely(config_file, updated_config)
        except Exception as e:
            self.logger.warning(f"Could not save updated config: {e}")
        
        return updated_config
    
    def _validate_config_values(self, config: Dict[str, Any], config_file: str) -> Dict[str, Any]:
        """ì„¤ì • ê°’ ê²€ì¦"""
        if config_file == "mcp_config.json":
            return self._validate_mcp_config(config)
        elif config_file == ".env":
            return self._validate_env_config(config)
        else:
            return config
    
    def _validate_mcp_config(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """MCP ì„¤ì • ê²€ì¦"""
        validated = {}
        
        for agent_name, servers in config.items():
            if not isinstance(servers, dict):
                self.logger.warning(f"Invalid server config for agent {agent_name}")
                continue
            
            validated_servers = {}
            for server_name, server_config in servers.items():
                if self._is_valid_mcp_server_config(server_config):
                    validated_servers[server_name] = server_config
                else:
                    self.logger.warning(f"Invalid MCP server config: {server_name}")
            
            if validated_servers:
                validated[agent_name] = validated_servers
        
        return validated
    
    def _is_valid_mcp_server_config(self, server_config: Dict[str, Any]) -> bool:
        """MCP ì„œë²„ ì„¤ì • ìœ íš¨ì„± ê²€ì¦"""
        if "command" in server_config and "args" in server_config:
            return isinstance(server_config["args"], list)
        elif "url" in server_config:
            return server_config["url"].startswith(("http://", "https://"))
        else:
            return False
    
    async def _create_default_config(self, config_file: str) -> Dict[str, Any]:
        """ê¸°ë³¸ ì„¤ì • íŒŒì¼ ìƒì„±"""
        default_config = self.default_configs.get(config_file, {})
        
        try:
            await self.save_config_safely(config_file, default_config)
            self.logger.info(f"Created default config file: {config_file}")
        except Exception as e:
            self.logger.error(f"Failed to create default config {config_file}: {e}")
        
        return default_config
    
    async def save_config_safely(
        self, 
        config_file: str, 
        config_data: Dict[str, Any]
    ) -> bool:
        """ì•ˆì „í•œ ì„¤ì • íŒŒì¼ ì €ì¥"""
        config_path = self.base_path / config_file
        backup_path = self.base_path / f"{config_file}.backup"
        
        try:
            # ê¸°ì¡´ íŒŒì¼ì´ ìˆìœ¼ë©´ ë°±ì—… ìƒì„±
            if config_path.exists():
                async with aiofiles.open(config_path, 'rb') as src:
                    async with aiofiles.open(backup_path, 'wb') as dst:
                        content = await src.read()
                        await dst.write(content)
            
            # ìƒˆ ì„¤ì • íŒŒì¼ ì‘ì„±
            if config_file.endswith('.json'):
                content = json.dumps(config_data, indent=2, ensure_ascii=False)
            elif config_file.endswith(('.yml', '.yaml')):
                content = yaml.dump(config_data, default_flow_style=False, allow_unicode=True)
            else:
                content = json.dumps(config_data, indent=2, ensure_ascii=False)
            
            async with aiofiles.open(config_path, 'w', encoding='utf-8') as file:
                await file.write(content)
            
            # ë°±ì—… íŒŒì¼ ì •ë¦¬ (ì„±ê³µì‹œ)
            if backup_path.exists():
                backup_path.unlink()
            
            return True
        
        except Exception as e:
            self.logger.error(f"Failed to save config {config_file}: {e}")
            
            # ë°±ì—…ì—ì„œ ë³µì› ì‹œë„
            if backup_path.exists():
                try:
                    async with aiofiles.open(backup_path, 'rb') as src:
                        async with aiofiles.open(config_path, 'wb') as dst:
                            content = await src.read()
                            await dst.write(content)
                    self.logger.info(f"Restored {config_file} from backup")
                except Exception as restore_error:
                    self.logger.error(f"Failed to restore from backup: {restore_error}")
            
            return False

# ì‚¬ìš© ì˜ˆì‹œ
async def load_mcp_config_safely() -> Dict[str, Any]:
    """ì•ˆì „í•œ MCP ì„¤ì • ë¡œë”©"""
    config_manager = ConfigurationManager()
    
    required_fields = ["reconnaissance", "initial_access", "planner"]
    
    config = await config_manager.load_config_safely(
        "mcp_config.json",
        required_fields=required_fields
    )
    
    return config
]]></correct-example>
<incorrect-example title="ê¸°ë³¸ íŒŒì¼ ì½ê¸°" conditions="íŒŒì¼ ì½ê¸°/ì“°ê¸° ì‘ì—…" expected-result="ì•ˆì •ì ì¸ íŒŒì¼ ì²˜ë¦¬" incorrectness-criteria="ì—ëŸ¬ ì²˜ë¦¬ì™€ ê²€ì¦ ë¡œì§ ëˆ„ë½"><![CDATA[
def load_config_basic(config_file: str) -> Dict[str, Any]:
    """ê¸°ë³¸ì ì¸ ì„¤ì • ë¡œë”© (ìœ„í—˜)"""
    # íŒŒì¼ ì¡´ì¬, ê¶Œí•œ, í˜•ì‹ ê²€ì¦ ì—†ì´ ë°”ë¡œ ë¡œë“œ
    with open(config_file, 'r') as file:
        return json.load(file)
]]></incorrect-example>
</example>
</examples>
</requirement>

<non-negotiable priority="critical">
<description>ì‹œìŠ¤í…œ ë³µêµ¬ê°€ ë¶ˆê°€ëŠ¥í•œ ì¹˜ëª…ì  ì—ëŸ¬ëŠ” ì•ˆì „í•œ ì¢…ë£Œ ì ˆì°¨ë¥¼ ë”°ë¥¸ë‹¤.</description>
<examples>
<example title="ì¹˜ëª…ì  ì—ëŸ¬ ì²˜ë¦¬">
<correct-example title="ì•ˆì „í•œ ì‹œìŠ¤í…œ ì¢…ë£Œ" conditions="ë³µêµ¬ ë¶ˆê°€ëŠ¥í•œ ì—ëŸ¬ ë°œìƒ" expected-result="ë°ì´í„° ì†ì‹¤ ë°©ì§€" correctness-criteria="ì•ˆì „í•œ ì¢…ë£Œì™€ ìƒíƒœ ì €ì¥"><![CDATA[
import signal
import sys
import asyncio
from typing import Dict, Any, List, Callable
import atexit
import logging

class CriticalErrorHandler:
    """ì¹˜ëª…ì  ì—ëŸ¬ í•¸ë“¤ëŸ¬"""
    
    def __init__(self):
        self.logger = logging.getLogger("critical_errors")
        self.shutdown_hooks: List[Callable] = []
        self.is_shutting_down = False
        self.setup_signal_handlers()
    
    def setup_signal_handlers(self):
        """ì‹œê·¸ë„ í•¸ë“¤ëŸ¬ ì„¤ì •"""
        signal.signal(signal.SIGINT, self.handle_shutdown_signal)
        signal.signal(signal.SIGTERM, self.handle_shutdown_signal)
        
        # ì •ìƒ ì¢…ë£Œ ì‹œ cleanup ì‹¤í–‰
        atexit.register(self.cleanup_on_exit)
    
    def register_shutdown_hook(self, hook: Callable):
        """ì¢…ë£Œ ì‹œ ì‹¤í–‰í•  í›… ë“±ë¡"""
        self.shutdown_hooks.append(hook)
    
    async def handle_critical_error(
        self, 
        error: Exception,
        component: str,
        context: Dict[str, Any] = None
    ) -> None:
        """ì¹˜ëª…ì  ì—ëŸ¬ ì²˜ë¦¬"""
        if self.is_shutting_down:
            return
        
        self.is_shutting_down = True
        
        try:
            # 1. ì¹˜ëª…ì  ì—ëŸ¬ ë¡œê¹…
            await self._log_critical_error(error, component, context)
            
            # 2. í˜„ì¬ ìƒíƒœ ì €ì¥
            await self._save_system_state(context)
            
            # 3. ì§„í–‰ ì¤‘ì¸ ì‘ì—… ì•ˆì „í•˜ê²Œ ì¤‘ë‹¨
            await self._abort_running_operations()
            
            # 4. ë¦¬ì†ŒìŠ¤ ì •ë¦¬
            await self._cleanup_resources()
            
            # 5. ì—ëŸ¬ ë³´ê³ 
            await self._send_critical_error_report(error, component, context)
            
            # 6. ì•ˆì „í•œ ì¢…ë£Œ
            await self._safe_shutdown()
        
        except Exception as shutdown_error:
            # ì¢…ë£Œ ê³¼ì •ì—ì„œë„ ì—ëŸ¬ê°€ ë°œìƒí•œ ê²½ìš° ê°•ì œ ì¢…ë£Œ
            self.logger.critical(f"Error during shutdown: {shutdown_error}")
            sys.exit(1)
    
    async def _log_critical_error(
        self, 
        error: Exception, 
        component: str, 
        context: Dict[str, Any]
    ) -> None:
        """ì¹˜ëª…ì  ì—ëŸ¬ ë¡œê¹…"""
        error_info = {
            "timestamp": datetime.now().isoformat(),
            "component": component,
            "error_type": type(error).__name__,
            "error_message": str(error),
            "stack_trace": traceback.format_exc(),
            "context": context or {},
            "system_info": {
                "python_version": sys.version,
                "platform": sys.platform
            }
        }
        
        # íŒŒì¼ê³¼ ì½˜ì†”ì— ëª¨ë‘ ë¡œê¹…
        self.logger.critical(f"CRITICAL ERROR: {json.dumps(error_info, indent=2)}")
        
        # ì—ëŸ¬ ì •ë³´ë¥¼ ë³„ë„ íŒŒì¼ì— ì €ì¥
        try:
            error_file = f"critical_error_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            async with aiofiles.open(error_file, 'w') as f:
                await f.write(json.dumps(error_info, indent=2))
        except Exception as e:
            print(f"Failed to save error details: {e}")
    
    async def _save_system_state(self, context: Dict[str, Any]) -> None:
        """í˜„ì¬ ì‹œìŠ¤í…œ ìƒíƒœ ì €ì¥"""
        try:
            state_info = {
                "timestamp": datetime.now().isoformat(),
                "active_agents": self._get_active_agents(),
                "running_operations": self._get_running_operations(),
                "memory_state": await self._get_memory_state(),
                "configuration": self._get_current_config(),
                "context": context or {}
            }
            
            state_file = f"system_state_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
            async with aiofiles.open(state_file, 'w') as f:
                await f.write(json.dumps(state_info, indent=2))
            
            self.logger.info(f"System state saved to {state_file}")
        
        except Exception as e:
            self.logger.error(f"Failed to save system state: {e}")
    
    async def _abort_running_operations(self) -> None:
        """ì§„í–‰ ì¤‘ì¸ ì‘ì—… ì•ˆì „í•˜ê²Œ ì¤‘ë‹¨"""
        try:
            # ì‹¤í–‰ ì¤‘ì¸ ì—ì´ì „íŠ¸ ì‘ì—… ì¤‘ë‹¨
            active_tasks = [task for task in asyncio.all_tasks() if not task.done()]
            
            if active_tasks:
                self.logger.info(f"Cancelling {len(active_tasks)} running tasks")
                
                for task in active_tasks:
                    task.cancel()
                
                # ì‘ì—… ì¤‘ë‹¨ ì™„ë£Œ ëŒ€ê¸° (íƒ€ì„ì•„ì›ƒ ì„¤ì •)
                try:
                    await asyncio.wait_for(
                        asyncio.gather(*active_tasks, return_exceptions=True),
                        timeout=30.0
                    )
                except asyncio.TimeoutError:
                    self.logger.warning("Some tasks did not cancel within timeout")
        
        except Exception as e:
            self.logger.error(f"Error aborting operations: {e}")
    
    async def _cleanup_resources(self) -> None:
        """ë¦¬ì†ŒìŠ¤ ì •ë¦¬"""
        try:
            # ë“±ë¡ëœ ì¢…ë£Œ í›… ì‹¤í–‰
            for hook in self.shutdown_hooks:
                try:
                    if asyncio.iscoroutinefunction(hook):
                        await hook()
                    else:
                        hook()
                except Exception as e:
                    self.logger.error(f"Error in shutdown hook: {e}")
            
            # íŒŒì¼ í•¸ë“¤ ì •ë¦¬
            await self._close_file_handles()
            
            # ë„¤íŠ¸ì›Œí¬ ì—°ê²° ì •ë¦¬
            await self._close_network_connections()
            
        except Exception as e:
            self.logger.error(f"Error during resource cleanup: {e}")
    
    async def _send_critical_error_report(
        self, 
        error: Exception, 
        component: str, 
        context: Dict[str, Any]
    ) -> None:
        """ì¹˜ëª…ì  ì—ëŸ¬ ë³´ê³ """
        try:
            report = {
                "severity": "CRITICAL",
                "service": "Decepticon",
                "component": component,
                "error": str(error),
                "timestamp": datetime.now().isoformat(),
                "context": context
            }
            
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì´ë©”ì¼, Slack, ì›¹í›… ë“±ìœ¼ë¡œ ì•Œë¦¼
            print(f"ğŸš¨ CRITICAL SYSTEM ERROR ğŸš¨")
            print(f"Component: {component}")
            print(f"Error: {str(error)}")
            print(f"Time: {datetime.now()}")
            print("System is shutting down safely...")
        
        except Exception as e:
            self.logger.error(f"Failed to send error report: {e}")
    
    async def _safe_shutdown(self) -> None:
        """ì•ˆì „í•œ ì‹œìŠ¤í…œ ì¢…ë£Œ"""
        try:
            # ë¡œê·¸ í”ŒëŸ¬ì‹œ
            logging.shutdown()
            
            # ì •ìƒ ì¢…ë£Œ ì½”ë“œë¡œ ì¢…ë£Œ
            sys.exit(0)
        
        except Exception as e:
            # ê°•ì œ ì¢…ë£Œ
            print(f"Forced shutdown due to: {e}")
            sys.exit(1)
    
    def handle_shutdown_signal(self, signum, frame):
        """ì‹œê·¸ë„ í•¸ë“¤ëŸ¬"""
        print(f"\nReceived signal {signum}, initiating safe shutdown...")
        
        # ë¹„ë™ê¸° ì»¨í…ìŠ¤íŠ¸ì—ì„œ ì¢…ë£Œ ì²˜ë¦¬
        loop = asyncio.get_event_loop()
        loop.create_task(self.handle_critical_error(
            Exception(f"Shutdown signal {signum}"),
            "signal_handler"
        ))
    
    def cleanup_on_exit(self):
        """í”„ë¡œê·¸ë¨ ì¢…ë£Œ ì‹œ cleanup"""
        if not self.is_shutting_down:
            print("Performing final cleanup...")

# ì „ì—­ ì—ëŸ¬ í•¸ë“¤ëŸ¬
_critical_handler = CriticalErrorHandler()

def register_shutdown_hook(hook: Callable):
    """ì¢…ë£Œ í›… ë“±ë¡"""
    _critical_handler.register_shutdown_hook(hook)

async def handle_critical_system_error(error: Exception, component: str, context: Dict[str, Any] = None):
    """ì¹˜ëª…ì  ì‹œìŠ¤í…œ ì—ëŸ¬ ì²˜ë¦¬"""
    await _critical_handler.handle_critical_error(error, component, context)

# ì‚¬ìš© ì˜ˆì‹œ
async def protected_main_operation():
    """ë³´í˜¸ëœ ë©”ì¸ ì‘ì—…"""
    try:
        # ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ ë¡œì§
        await run_application()
    
    except MemoryError as e:
        await handle_critical_system_error(e, "memory_manager", {"available_memory": get_available_memory()})
    
    except SystemExit as e:
        await handle_critical_system_error(e, "system", {"exit_code": e.code})
    
    except Exception as e:
        # ì˜ˆìƒì¹˜ ëª»í•œ ì¹˜ëª…ì  ì—ëŸ¬
        if is_critical_error(e):
            await handle_critical_system_error(e, "application", {"operation": "main"})
        else:
            # ì¼ë°˜ ì—ëŸ¬ëŠ” ë¡œê¹…ë§Œ
            logger.error(f"Non-critical error: {e}")

def is_critical_error(error: Exception) -> bool:
    """ì¹˜ëª…ì  ì—ëŸ¬ ì—¬ë¶€ íŒë‹¨"""
    critical_types = [MemoryError, SystemError, OSError]
    critical_keywords = ["corruption", "fatal", "disk full", "permission denied"]
    
    if any(isinstance(error, error_type) for error_type in critical_types):
        return True
    
    error_message = str(error).lower()
    return any(keyword in error_message for keyword in critical_keywords)
]]></correct-example>
<incorrect-example title="ê¸°ë³¸ ì˜ˆì™¸ ì²˜ë¦¬" conditions="ë³µêµ¬ ë¶ˆê°€ëŠ¥í•œ ì—ëŸ¬ ë°œìƒ" expected-result="ë°ì´í„° ì†ì‹¤ ë°©ì§€" incorrectness-criteria="ì•ˆì „í•œ ì¢…ë£Œ ì ˆì°¨ ëˆ„ë½"><![CDATA[
def main_application():
    """ê¸°ë³¸ì ì¸ ì˜ˆì™¸ ì²˜ë¦¬ (ìœ„í—˜)"""
    try:
        run_application()
    except Exception as e:
        # ìƒíƒœ ì €ì¥, ë¦¬ì†ŒìŠ¤ ì •ë¦¬, ì•ˆì „í•œ ì¢…ë£Œ ì—†ì´ ë°”ë¡œ ì¢…ë£Œ
        print(f"Error: {e}")
        sys.exit(1)
]]></incorrect-example>
</example>
</examples>
</non-negotiable>
</requirements>

<context description="ì—ëŸ¬ ì²˜ë¦¬ ì»¨í…ìŠ¤íŠ¸">
Decepticonì€ ë³µì¡í•œ ë©€í‹° ì—ì´ì „íŠ¸ ì‹œìŠ¤í…œìœ¼ë¡œ, ë‹¤ì–‘í•œ ì™¸ë¶€ ì˜ì¡´ì„±ê³¼ ìƒí˜¸ì‘ìš©í•©ë‹ˆë‹¤.
ì•ˆì •ì ì¸ ë™ì‘ì„ ìœ„í•´ì„œëŠ” ì˜ˆì¸¡ ê°€ëŠ¥í•œ ì—ëŸ¬ì™€ ì˜ˆìƒì¹˜ ëª»í•œ ì—ëŸ¬ ëª¨ë‘ì— ëŒ€í•œ ê°•ê±´í•œ ì²˜ë¦¬ê°€ í•„ìš”í•©ë‹ˆë‹¤.
ì‚¬ìš©ì ê²½í—˜ì„ ìœ„í•´ ê¸°ìˆ ì ì¸ ì—ëŸ¬ë¥¼ ì´í•´í•˜ê¸° ì‰¬ìš´ ë©”ì‹œì§€ë¡œ ë³€í™˜í•˜ê³ , ê°€ëŠ¥í•œ ë³µêµ¬ ë°©ë²•ì„ ì œì‹œí•´ì•¼ í•©ë‹ˆë‹¤.
</context>

<references>
<reference as="dependency" href=".cursor/rules/main-project-rules.mdc" reason="ê¸°ë³¸ í”„ë¡œì íŠ¸ ê·œì¹™">ë©”ì¸ í”„ë¡œì íŠ¸ ê·œì¹™</reference>
<reference as="context" href=".cursor/rules/async-patterns.mdc" reason="ë¹„ë™ê¸° ì—ëŸ¬ ì²˜ë¦¬">ë¹„ë™ê¸° í”„ë¡œê·¸ë˜ë° íŒ¨í„´</reference>
<reference as="context" href=".cursor/rules/ai-agents.mdc" reason="ì—ì´ì „íŠ¸ ì—ëŸ¬ ì²˜ë¦¬">AI ì—ì´ì „íŠ¸ ê°œë°œ ê·œì¹™</reference>
</references>
</rule>
