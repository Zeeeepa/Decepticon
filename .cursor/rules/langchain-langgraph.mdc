---
description: LangChain/LangGraph 개발을 위한 최적화된 패턴과 규칙
globs: "src/**/*.py"
alwaysApply: false
---

<rule>
<meta>
<title>LangChain/LangGraph Development Standards</title>
<description>LangChain과 LangGraph를 활용한 AI 에이전트 개발의 모범 사례</description>
<created-at utc-timestamp="1720684800">2025-07-08, 11:05 AM KST</created-at>
<last-updated-at utc-timestamp="1720684800">2025-07-08, 11:05 AM KST</last-updated-at>
<applies-to>
<file-matcher glob="src/agents/**/*.py">에이전트 관련 파일</file-matcher>
<file-matcher glob="src/graphs/**/*.py">그래프 구조 파일</file-matcher>
<file-matcher glob="src/tools/**/*.py">도구 관련 파일</file-matcher>
</applies-to>
</meta>

<requirements>
<requirement priority="critical">
<description>LangGraph 에이전트는 create_react_agent를 사용하여 생성하고 적절한 메모리 store를 연결한다.</description>
<examples>
<example title="LangGraph 에이전트 생성">
<correct-example title="올바른 에이전트 생성" conditions="새로운 에이전트 구현" expected-result="표준화된 에이전트" correctness-criteria="create_react_agent 사용과 store 연결"><![CDATA[
from langgraph.prebuilt import create_react_agent
from langmem import create_manage_memory_tool, create_search_memory_tool
from src.utils.llm.config_manager import get_current_llm
from src.utils.memory import get_store
from src.prompts.prompt_loader import load_prompt

async def make_custom_agent():
    """사용자 정의 에이전트 생성"""
    llm = get_current_llm()
    if llm is None:
        from langchain_anthropic import ChatAnthropic
        llm = ChatAnthropic(model="claude-3-5-sonnet-latest", temperature=0)
        print("Warning: Using default LLM model")
    
    # 중앙 집중식 store 사용
    store = get_store()
    
    # MCP 도구 로드
    mcp_tools = await load_mcp_tools(agent_name=["custom_agent"])
    
    # 메모리 도구 추가
    memory_tools = [
        create_manage_memory_tool(namespace=("memories",)),
        create_search_memory_tool(namespace=("memories",))
    ]
    
    # 핸드오프 도구 추가
    handoff_tools = [handoff_to_planner, handoff_to_summary]
    
    tools = mcp_tools + memory_tools + handoff_tools
    
    agent = create_react_agent(
        llm,
        tools=tools,
        store=store,
        name="CustomAgent",
        prompt=load_prompt("custom_agent", "swarm")
    )
    return agent
]]></correct-example>
<incorrect-example title="수동 에이전트 구성" conditions="새로운 에이전트 구현" expected-result="표준화된 에이전트" incorrectness-criteria="create_react_agent 미사용"><![CDATA[
from langchain.agents import initialize_agent

def make_custom_agent():
    """수동 에이전트 구성"""
    llm = ChatOpenAI(temperature=0)
    tools = [some_tool]
    
    # 표준 패턴이 아닌 수동 구성
    agent = initialize_agent(
        tools, 
        llm, 
        agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION
    )
    return agent
]]></incorrect-example>
</example>
</examples>
</requirement>

<requirement priority="high">
<description>메시지 처리 시 적절한 메시지 타입(HumanMessage, AIMessage, ToolMessage)을 사용한다.</description>
<examples>
<example title="메시지 타입 사용">
<correct-example title="올바른 메시지 타입" conditions="메시지 생성" expected-result="타입 안전한 메시지" correctness-criteria="적절한 메시지 클래스 사용"><![CDATA[
from langchain_core.messages import HumanMessage, AIMessage, ToolMessage

def create_conversation_messages(user_input: str, agent_response: str, tool_output: str) -> List[BaseMessage]:
    """대화 메시지 생성"""
    messages = [
        HumanMessage(content=user_input),
        AIMessage(
            content=agent_response,
            tool_calls=[{
                "name": "scan_network",
                "args": {"target": "192.168.1.1"},
                "id": "tool_call_123"
            }]
        ),
        ToolMessage(
            content=tool_output,
            tool_call_id="tool_call_123"
        )
    ]
    return messages
]]></correct-example>
<incorrect-example title="일반적인 딕셔너리 사용" conditions="메시지 생성" expected-result="타입 안전한 메시지" incorrectness-criteria="메시지 타입 클래스 미사용"><![CDATA[
def create_conversation_messages(user_input: str, agent_response: str, tool_output: str) -> List[Dict]:
    """딕셔너리 기반 메시지"""
    messages = [
        {"type": "human", "content": user_input},
        {"type": "ai", "content": agent_response},
        {"type": "tool", "content": tool_output}
    ]
    return messages
]]></incorrect-example>
</example>
</examples>
</requirement>

<requirement priority="high">
<description>Swarm 그래프는 동적으로 생성하며 모든 에이전트가 동일한 LLM 설정을 공유한다.</description>
<examples>
<example title="Swarm 그래프 생성">
<correct-example title="동적 Swarm 생성" conditions="Swarm 그래프 구축" expected-result="유연한 그래프 구조" correctness-criteria="동적 에이전트 로드"><![CDATA[
from langgraph.graph import MessagesState, StateGraph, START, END
from src.agents.swarm.Planner import make_planner_agent
from src.agents.swarm.Recon import make_recon_agent
from src.agents.swarm.InitAccess import make_initial_access_agent
from src.agents.swarm.Summary import make_summary_agent

async def create_dynamic_swarm():
    """동적 Swarm 그래프 생성"""
    # 모든 에이전트 비동기 생성
    agents = {
        "planner": await make_planner_agent(),
        "reconnaissance": await make_recon_agent(),
        "initial_access": await make_initial_access_agent(),
        "summary": await make_summary_agent()
    }
    
    # 그래프 구조 정의
    workflow = StateGraph(MessagesState)
    
    # 에이전트들을 노드로 추가
    for name, agent in agents.items():
        workflow.add_node(name, agent)
    
    # 진입점 설정
    workflow.add_edge(START, "planner")
    
    # 조건부 라우팅 추가
    workflow.add_conditional_edges(
        "planner",
        lambda state: determine_next_agent(state),
        ["reconnaissance", "initial_access", "summary", END]
    )
    
    return workflow.compile()
]]></correct-example>
<incorrect-example title="정적 그래프 구성" conditions="Swarm 그래프 구축" expected-result="유연한 그래프 구조" incorrectness-criteria="하드코딩된 구조"><![CDATA[
def create_static_swarm():
    """정적 그래프 구성"""
    workflow = StateGraph(MessagesState)
    
    # 하드코딩된 에이전트 추가
    workflow.add_node("agent1", some_hardcoded_agent)
    workflow.add_node("agent2", another_hardcoded_agent)
    
    # 고정된 흐름
    workflow.add_edge(START, "agent1")
    workflow.add_edge("agent1", "agent2")
    workflow.add_edge("agent2", END)
    
    return workflow.compile()
]]></incorrect-example>
</example>
</examples>
</requirement>

<requirement priority="medium">
<description>프롬프트는 prompt_loader를 통해 외부 파일에서 로드한다.</description>
<examples>
<example title="프롬프트 로딩">
<correct-example title="외부 프롬프트 파일 사용" conditions="에이전트 프롬프트 설정" expected-result="유지보수 가능한 프롬프트" correctness-criteria="prompt_loader 사용"><![CDATA[
from src.prompts.prompt_loader import load_prompt

async def make_specialized_agent():
    """특화된 에이전트 생성"""
    llm = get_current_llm()
    store = get_store()
    tools = await load_specialized_tools()
    
    # 외부 프롬프트 파일에서 로드
    agent = create_react_agent(
        llm,
        tools=tools,
        store=store,
        name="SpecializedAgent",
        prompt=load_prompt("specialized_agent", "swarm")
    )
    return agent
]]></correct-example>
<incorrect-example title="인라인 프롬프트" conditions="에이전트 프롬프트 설정" expected-result="유지보수 가능한 프롬프트" incorrectness-criteria="하드코딩된 프롬프트"><![CDATA[
async def make_specialized_agent():
    """인라인 프롬프트 사용"""
    llm = get_current_llm()
    tools = await load_specialized_tools()
    
    # 하드코딩된 프롬프트
    prompt = "You are a specialized agent. Do what the user asks."
    
    agent = create_react_agent(
        llm,
        tools=tools,
        name="SpecializedAgent", 
        prompt=prompt
    )
    return agent
]]></incorrect-example>
</example>
</examples>
</requirement>

<non-negotiable priority="critical">
<description>모든 도구 호출은 안전하게 처리하고 예외 상황에 대비한다.</description>
<examples>
<example title="안전한 도구 호출">
<correct-example title="예외 처리가 포함된 도구 호출" conditions="MCP 도구 실행" expected-result="안정적인 도구 실행" correctness-criteria="try-catch와 검증 로직"><![CDATA[
async def execute_security_tool(tool_name: str, target: str, **kwargs) -> Dict[str, Any]:
    """보안 도구 안전 실행"""
    try:
        # 입력 검증
        if not target or not is_valid_target(target):
            raise ValueError(f"Invalid target: {target}")
        
        # 도구 실행
        result = await security_tools[tool_name].execute(
            target=target,
            **kwargs
        )
        
        # 결과 검증
        if not result or "error" in result:
            raise RuntimeError(f"Tool execution failed: {result}")
        
        return {
            "status": "success",
            "tool": tool_name,
            "target": target,
            "result": result
        }
        
    except Exception as e:
        logger.error(f"Tool execution error: {e}")
        return {
            "status": "error",
            "tool": tool_name,
            "target": target,
            "error": str(e)
        }
]]></correct-example>
<incorrect-example title="검증 없는 도구 호출" conditions="MCP 도구 실행" expected-result="안정적인 도구 실행" incorrectness-criteria="예외 처리 및 검증 누락"><![CDATA[
async def execute_security_tool(tool_name: str, target: str, **kwargs) -> Dict[str, Any]:
    """검증 없는 도구 실행"""
    # 검증 없이 바로 실행
    result = await security_tools[tool_name].execute(target=target, **kwargs)
    return result
]]></incorrect-example>
</example>
</examples>
</non-negotiable>
</requirements>

<context description="LangChain/LangGraph 컨텍스트">
Decepticon은 LangChain과 LangGraph를 기반으로 하는 멀티 에이전트 시스템입니다.
각 에이전트는 create_react_agent로 생성되며, 중앙 집중식 메모리 store를 공유합니다.
Swarm 아키텍처를 통해 에이전트들이 서로 협력하여 복잡한 보안 테스팅 작업을 수행합니다.
</context>

<references>
<reference as="dependency" href=".cursor/rules/main-project-rules.mdc" reason="기본 프로젝트 규칙">메인 프로젝트 규칙</reference>
<reference as="context" href=".cursor/rules/mcp-integration.mdc" reason="MCP 도구 통합">MCP 통합 규칙</reference>
<reference as="context" href=".cursor/rules/ai-agents.mdc" reason="AI 에이전트 개발">에이전트 개발 규칙</reference>
</references>
</rule>
