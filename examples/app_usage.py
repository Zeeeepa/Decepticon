# app.py에서 새로운 객체지향 구조 활용 예시\n\nfrom src.utils.message import MessageProcessor, StreamlitMessageDisplay\n\nclass DecepticonApp:\n    def __init__(self):\n        # 통합 메시지 처리기 초기화\n        self.message_processor = MessageProcessor()\n        \n        # Streamlit 메시지 표시기 초기화\n        self.message_display = StreamlitMessageDisplay(self.chat_ui)\n    \n    async def execute_workflow(self, user_input: str, chat_area, agents_container):\n        \"\"\"워크플로우 실행 - 객체지향 방식\"\"\"\n        \n        # 중복 체크 초기화 (새 워크플로우 시작)\n        self.message_processor.reset_duplicate_check()\n        \n        # 사용자 메시지 표시\n        self.message_display.display_user_message(user_input)\n        \n        async for event in self.executor.execute_workflow(user_input, config=st.session_state.thread_config):\n            # 이벤트를 ProcessedMessage로 변환\n            processed_message = self.message_processor.process_event_data(event)\n            \n            # 중복 메시지 체크\n            if not self.message_processor.is_duplicate_message(processed_message):\n                # 메시지 타입에 따라 적절한 표시\n                if processed_message.type == \"ai\":\n                    self.message_display.display_agent_message(\n                        processed_message.agent_name,\n                        processed_message.content,\n                        processed_message.tool_calls\n                    )\n                elif processed_message.type == \"tool\":\n                    self.message_display.display_tool_message(\n                        processed_message.tool_name,\n                        processed_message.content\n                    )\n                \n                # 구조화된 메시지 저장 (기존 호환성)\n                st.session_state.structured_messages.append(processed_message.to_dict())\n\n# 기존 CLIMessageProcessor 대체 가능\n# self.message_processor = CLIMessageProcessor() \n# ↓\n# self.message_processor = MessageProcessor()\n# self.message_display = StreamlitMessageDisplay(self.chat_ui)\n